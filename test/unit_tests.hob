assert = \a b.if a == b then () else println("assertion failed: " ++ show(a) ++ " != " ++ show(b))

type maybeInt = (()+int)
type maybeLong = (()+long)
type maybeChar = (()+char)

///////////////////////////
//    native functions
///////////////////////////

/** alli

  if all elements in the array satisfy the predicate `f` from `begin`, return true
  else return false

  tempalte <typename T>
  bool alli(std::function<bool(T)> f, long begin, array<T>& xs) {
    return std::all_of(xs.cbegin() + begin, xs.cend(), f);
  }
*/

assert(alli(\x.x>3, 1L, [4]), true)
assert(alli(\x.x>3, 1L, [4, 5]), true)
assert(alli(\x.x>3, 1L, [4, 3]), false)
assert(alli(\x.x>3, 1L, [4, 3, 4]), false)
assert(alli(\x.x>3, 1L, [4, 5, 4]), true)

/** all
  
  if all elements in the array satisfy the predicate `f`, return true
  else return false

  template <typename T>
  bool all(std::function<bool(T)> f, array<T>& xs) {
    return std::all_of(xs.cbegin(), xs.cend(), f);
  }
*/

assert(all(\x.x>3, []::[int]), true)
assert(all(\x.x>3, [5]), true)
assert(all(\x.x>3, [3]), false)
assert(all(\x.x>3, [3, 4]), false)
assert(all(\x.x>3, [5, 4]), true)

/** anyi

  if any element in the array satisfies the predicate `f` from `begin`, return true
  else return false

  template <typename T>
  bool anyi(std::function<bool(T)> f, long begin, array<T>& xs) {
    return std::any_of(xs.cbegin() + begin, xs.cend(), f);
  }
*/

assert(anyi(\x.x>3, 1L, [4]), false)
assert(anyi(\x.x>3, 1L, [4, 5]), true)
assert(anyi(\x.x>3, 1L, [4, 3]), false)
assert(anyi(\x.x>3, 1L, [4, 3, 4]), true)
assert(anyi(\x.x>3, 1L, [4, 5, 4]), true)

/** any
  
  if any element in the array satisfies the predicate `f`, return true
  else return false

  template <typename T>
  bool any(std::function<bool(T)> f, array<T>& xs) {
    return std::any_of(xs.cbegin(), xs.cend(), f);
  }
*/

assert(any(\x.x>3, []::[int]), false)
assert(any(\x.x>3, [5]), true)
assert(any(\x.x>3, [3]), false)
assert(any(\x.x>3, [3, 4]), true)


/** anyiC

  just like `anyi`, but the predicate must be a closure
*/

assert(anyiC(toClosure(\x.x>3), 1L, [4]), false)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 5]), true)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 3]), false)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 3, 4]), true)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 5, 4]), true)

/** anyC
  
  just like `any`, but the predicate must be a closure
*/

assert(anyC(toClosure(\x.x>3), []::[int]), false)
assert(anyC(toClosure(\x.x>3), [5]), true)
assert(anyC(toClosure(\x.x>3), [3]), false)
assert(anyC(toClosure(\x.x>3), [3, 4]), true)


/** somei

  if some elements in the array satisfy the predicate `f` from `begin`, return `maybe(T)`
  else return false

  template <typename T>
  maybe<T> somei(std::function<bool(T)> f, array<T>& xs, long begin) {
    const auto it = std::find_if(xs.cbegin() + begin, xs.cend(), f);
    return (it == xs.cend()) ? nothing<T>() : just<T>(*it);
  }
*/

assert(somei(\x.x>3, [4], 0L), 4)
assert(somei(\x.x>3, [4, 3, 5], 1L), 5)
assert(somei(\x.x>3, [4, 3, 2, 1], 1L), nothing::maybeInt)

/** some

  if some elements in the array satisfy the predicate `f`, return `maybe(T)`
  else return false

  template <typename T>
  maybe<T> some(std::function<bool(T)> f, array<T>& xs) {
    const auto it = std::find_if(xs.cbegin(), xs.cend(), f);
    return (it == xs.cend()) ? nothing<T>() : just<T>(*it);
  }
*/

assert(some(\x.x>3, []::[int]), nothing::maybeInt)
assert(some(\x.x>3, [3, 5]), 5)
assert(some(\x.x>3, [3, 2, 1]), nothing::maybeInt)

/** someiC

  just like `somei`, but the predicate must be a closure
*/

assert(someiC(toClosure(\x.x>3), [4], 0L), 4)
assert(someiC(toClosure(\x.x>3), [4, 3, 5], 1L), 5)
assert(someiC(toClosure(\x.x>3), [4, 3, 2, 1], 1L), nothing::maybeInt)

/** someC

  just like `some`, but the predicate must be a closure
*/

assert(someC(toClosure(\x.x>3), []::[int]), nothing::maybeInt)
assert(someC(toClosure(\x.x>3), [3, 5]), 5)
assert(someC(toClosure(\x.x>3), [3, 2, 1]), nothing::maybeInt)


/** amap

  starting from position `begin`, for every element in array `src`, apply `f` to it,
  and store the result in the corresponding position in array `dst`

  template <typename T, typename U>
  array<U>& amap(std::function<U(T)> f, long begin, array<T>& dst, array<U>& src) {
    std::transform(src.cbegin() + begin, src.cend(), dst.begin() + begin, f);
    return dst;
  }
*/

assert(amap(\x.x+1, 0L, []::[int], []::[int]), []::[int])
do {
  b = newArray(1L);
  copy(b, 0L, [3]);
  assert(amap(\x.x+1, 1L, b, [4]), b);
}
do {
  b = newArray(2L);
  copy(b, 0L, [3, 4]);
  assert(amap(\x.x+1, 0L, b, [4, 5]), [5, 6]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(amap(\x.x+1, 1L, b, [4, 5, 6]), [3, 6, 7]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(amap(\x.x+1, 1L, b, [4, 5]), [3, 6, 5]);
}

/** amapRange

  starting from position `begin` to `end` (exclusive), for every element in array `src`, apply `f` to it,
  and store the result in the corresponding position in array `dst` starts from index `dstBegin`

  template <typename T, typename U>
  array<U> amapRange(std::function<U(T)> f, array<T>& src, long begin, long end, array<T>& dst, long dstBegin) {
    std::transform(src.cbegin() + begin, src.cbegin() + end, dst.begin() + dstBegin, f);
    return dst;
  }
*/

assert(amapRange(\x.x+1, []::[int], 0L, 0L, []::[int], 0L), []::[int])
do {
  b = newArray(1L);
  copy(b, 0L, [33]);
  assert(amapRange(\x.x+1, [4], 0L, 1L, b, 0L), [5]);
}
do {
  b = newArray(2L);
  copy(b, 0L, [33, 33]);
  assert(amapRange(\x.x+1, [4, 5], 0L, 2L, b, 0L), [5, 6]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [33, 33, 33]);
  assert(amapRange(\x.x+1, [4, 5, 6], 0L, 2L, b, 1L), [33, 5, 6]);
}

/** map

  just like `amap`, but the destination array is created by the function

  template <typename T, typename U>
  array<U> map(std::function<U(T)> f, array<T>& src) {
    array<U> dst(src.size());
    std::transform(src.cbegin(), src.cend(), dst.begin(), f);
    return dst;
  }
*/

assert(map(\x.x+1, []::[int]), []::[int])
assert(map(\x.x+1, [4]), [5])
assert(map(\x.x+1, [4, 5]), [5, 6])

/** mapRange

  just like `amapRange`, but the destination array is created by the function

  template <typename T, typename U>
  array<U> mapRange(std::function<U(T)> f, long begin, long end, array<T>& src) {
    array<U> dst(end - begin);
    std::transform(src.cbegin() + begin, src.cbegin() + end, dst.begin(), f);
    return dst;
  }
*/

assert(mapRange(\x.x+1, 0L, 0L, []::[int]), []::[int])
assert(mapRange(\x.x+1, 0L, 1L, [4]), [5])
assert(mapRange(\x.x+1, 0L, 1L, [4, 5]), [5])

/** mapiC

  just like `amap`, but the function must be a closure
*/

assert(mapiC(toClosure(\x.x+1), 0L, []::[int], []::[int]), []::[int])
do {
  b = newArray(1L);
  copy(b, 0L, [3]);
  assert(mapiC(toClosure(\x.x+1), 1L, b, [4]), b);
}
do {
  b = newArray(2L);
  copy(b, 0L, [3, 4]);
  assert(mapiC(toClosure(\x.x+1), 0L, b, [4, 5]), [5, 6]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(mapiC(toClosure(\x.x+1), 1L, b, [4, 5, 6]), [3, 6, 7]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(mapiC(toClosure(\x.x+1), 1L, b, [4, 5]), [3, 6, 5]);
}

/** mapC

  just like `map`, but the function must be a closure
*/

assert(mapC(toClosure(\x.x+1), []::[int]), []::[int])
assert(mapC(toClosure(\x.x+1), [4]), [5])
assert(mapC(toClosure(\x.x+1), [4, 5]), [5, 6])

/** mapIdxStep

  dst[i] = f(src, i);

  template <typename T, typename U>
  array<U> mapIdxStep(std::function<U(array<T>&, long)> f, array<T>& src, long begin, array<U>& dst) {
    std::transform(src.cbegin() + begin, src.cend(), dst.begin() + begin, f);
    return dst;
  }
*/

assert(mapIdxStep(\xs i.xs[i]-1, []::[int], 0L, []::[int]), []::[int])
do {
  b = newArray(3L);
  copy(b, 0L, [5, 7, 9]);
  assert(mapIdxStep(\xs i.xs[i]-1, [3, 4], 1L, b), [5, 3, 9]);
}

/** mapIdx

  just like `mapIdxStep`, but the destination array is created by the function

  template <typename T, typename U>
  array<U> mapIdx(std::function<U(array<T>&, long)> f, array<T>& src) {
    array<U> dst(src.size());
    std::transform(src.cbegin(), src.cend(), dst.begin(), f);
    return dst;
  }
*/

assert(mapIdx(\xs i.xs[i]-1, []::[int]), []::[int])
assert(mapIdx(\xs i.xs[i]-1, [3, 4]), [2, 3])

/** eachStep

  apply `f` to each element of `src` between indices [`begin`, `end`]

  template <typename T>
  void eachStep(std::function<void(T)> f, array<T>& src, long begin, long end) {
    std::for_each(src.cbegin() + begin, src.cbegin() + end + 1, f);
  }
*/

//eachStep(\x.print(x), [3, 4, 5], 1L, 2L) // prints 45

/** each

  just like `eachStep`, but apply `f` on every element of `src`

  template <typename T>
  void each(std::function<void(T)> f, array<T>& src) {
    eachStep(f, src, 0, src.size() - 1);
  }
*/

//each(\x.print(x), [3, 4, 5]) // prints 345

/** eachRange

  apply `f` to each number between [`begin`, `end`)

  template <typename T>
  void eachRange(std::function<void(T)> f, T begin, T end) {
    for (T i = begin; i < end; ++i) {
      f(i);
    }
  }
*/

// eachRagne(\x.print(x), 1, 3) // prints 12

/** eachiC

  just like `each`, but `f` must be a closure, and has a `begin` index

  template <typename T>
  void eachiC(std::function<void(T)> f, array<T>& src, T begin) {
    for (T i = begin; T <= src.size() - 1; ++i) {
      f(i);
    }
  }
*/

// eachiC(toClosure(print), [3, 4, 5], 1L) // prints 45

/** eachC

  just like `each`, but `f` must be a closure

  template <typename T>
  void eachC(std::function<void(T)> f, array<T>& src) {
    for (T i = 0; i <= src.size() - 1; ++i) {
      f(i);
    }
  }
*/

// eachC(toClosure(print), [3, 4, 5]) // prints 345

/** eachRangeC

  just like `eachRange`, but `f` must be a closure

  template <typename T>
  void eachRangeC(std::function<void(T)> f, T begin, T end) {
    for (T i = begin; i < end; ++i) {
      f(i);
    }
  }
*/

// eachRangeC(toClosure(print), 1, 3) // prints 12

/** foldli

  fold left from index `begin`

  template <typename T, typename Acc>
  U foldli(std::function<Acc(Acc, T)> f, Acc init, long begin, array<T>& src) {
    return std::accumulate(src.cbegin() + begin, src.cend(), init, f);
  }
*/

assert(foldli(\acc x.acc+x, 0, 0L, []::[int]), 0)
assert(foldli(\acc x.acc+x, 42, 1L, [3]), 42)
assert(foldli(\acc x.acc+x, 42, 1L, [1, 2, 3]), 42 + 2 + 3)

/** foldliRange

  fold left from index `begin` to `end` (exclusive)

  template <typename T, typename Acc>
  U foldliRange(std::function<Acc(Acc, T)> f, Acc init, long begin, long end, array<T>& src) {
    return std::accumulate(src.cbegin() + begin, src.cbegin() + end, init, f);
  }
*/

assert(foldliRange(\acc x.acc+x, 0, 0L, 0L, []::[int]), 0)
assert(foldliRange(\acc x.acc+x, 42, 0L, 1L, [3]), 42 + 3)
assert(foldliRange(\acc x.acc+x, 42, 1L, 3L, [3, 4, 5, 6]), 42 + 4 + 5)

/** foldlRange

  same as `foldliRange`, could be a mistake in `foldliRange`'s signature for missing starting index
*/

assert(foldlRange(\acc x.acc+x, 0, 0L, 0L, []::[int]), 0)
assert(foldlRange(\acc x.acc+x, 42, 0L, 1L, [3]), 42 + 3)
assert(foldlRange(\acc x.acc+x, 42, 1L, 3L, [3, 4, 5, 6]), 42 + 4 + 5)

/** copyRange

  copy elements from `src` between indices [`begin`, `end`) to `dst` starts from `dstStartIdx`

  template <typename T>
  void copyRange(array<T>& dst, long dstStartIdx, array<T>& src, long begin, long end) {
    std::copy(src.cbegin() + begin, src.cbegin() + end, dst.begin() + dstStartIdx);
  }
*/

do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyRange(b, 0L, [3, 4, 5], 1L, 2L);
  assert(b, [4, 33, 33]);
}
do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyRange(b, 1L, [3, 4, 5], 1L, 2L);
  assert(b, [33, 4, 33]);
}

/** copyFrom

  copy elements from `src` between `begin` to its end to `dst` starts from `dstStartIdx`

  template <typename T>
  void copyFrom(array<T>& dst, long dstStartIdx, array<T>& src, long begin) {
    std::copy(src.cbegin() + begin, src.cend(), dst.begin() + dstStartIdx);
  }
*/

do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyFrom(b, 0L, [3, 4, 5], 1L);
  assert(b, [4, 5, 33]);
}
do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyFrom(b, 1L, [3, 4, 5], 1L);
  assert(b, [33, 4, 5]);
}

/** copy

  copy elements from `src` to `dst` starts from `dstStartIdx`

  template <typename T>
  void copy(array<T>& dst, long dstStartIdx, array<T>& src) {
    std::copy(src.cbegin(), src.cend(), dst.begin() + dstStartIdx);
  }
*/

do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  assert(b, [33, 33, 33]);
}
do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copy(b, 1L, [3, 4, 5]);
  assert(b, [33, 3, 4]);
}

/** concatInto

  concat elements from `src` starts with index `begin`, and copy them into `dst` starts from `dstStartIdx`

  template <typename T>
  void concatInto(array<array<T>>& src, long begin, array<T>& dst, long dstBegin) {
    for (long i = begin; i < src.size(); ++i) {
      std::copy(src[i].cbegin(), src[i].cend(), dst.begin() + dstBegin);
      dstBegin += src[i].size();
    }
  }
*/

assert(concatInto(["hello", "abc", "defg"], 1L, newArray(7L), 0L), "abcdefg")

/** concat

  create an array contains the result of concated elements from `src`

  template <typename T>
  array<T> concat(array<array<T>>& src, array<T>& dst) {
    const auto size = std::accumulate(src.cbegin(), src.cend(), 0, [](long acc, const array<T>& x) {
      return acc + x.size();
    });
    array<T> result(size);
    long dstBegin = 0;
    for (long i = 0, dstBegin = 0; i < src.size(); ++i) {
      std::copy(src[i].cbegin(), src[i].cend(), result.begin() + dstBegin);
      dstBegin += src[i].size();
    }
    return result;
  }
*/

assert(concat(["hello", "abc", "defg"]), "helloabcdefg")

/** foldl

  fold left

  template <typename T, typename Acc>
  U foldl(std::function<Acc(Acc, T)> f, Acc init, array<T>& src) {
    return std::accumulate(src.begin(), src.end(), init, f);
  }
*/

assert(foldl(\acc x.acc+x, 0, []::[int]), 0)
assert(foldl(\acc x.acc+x, 42, [3]), 42 + 3)
assert(foldl(\acc x.acc+x, 42, [1, 2, 3]), 42 + 1 + 2 + 3)

/** foldri

  fold right from index `begin`-1

  template <typename T, typename Acc>
  U foldri(std::function<Acc(Acc, T)> f, Acc init, long begin, array<T>& src) {
    return std::accumulate(src.rbegin() + begin, src.rend(), init, f);
  }
*/

assert(foldri(\acc x.acc+x, 42, 1L, [3]), 42 + 3)
assert(foldri(\acc x.acc+x, 42, 1L, [1, 2, 3]), 42 + 1)

/** foldr

  fold right

  template <typename T, typename Acc>
  U foldr(std::function<Acc(Acc, T)> f, Acc init, array<T>& src) {
    return std::accumulate(src.rbegin(), src.rend(), init, f);
  }
*/

assert(foldr(\acc x.acc+x, 42, []::[int]), 42)
assert(foldr(\acc x.acc+x, 42, [3]), 42 + 3)
assert(foldr(\acc x.acc+x, 42, [1, 2, 3]), 42 + 1 + 2 + 3)

/** scanlStep

  scan left from index `begin`

  template <typename T, typename Acc>
  array<Acc> scanlStep(std::function<Acc(Acc, T)> f, Acc init, long begin, array<T>& src) {
    array<Acc> result(src.size() - begin + 1);
    std::exclusive_scan(src.cbegin() + begin, src.cend(), result.begin(), f);
    return result;
  }
*/

do {
  b = newArray(5L);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(scanlStep(\acc x.acc+x, 0, [1, 2, 3], 0L, b), [0, 1, 3, 6, 33]);
}

do {
  b = newArray(5L);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(scanlStep(\acc x.acc+x, 42, [1, 2, 3], 1L, b), [33, 42, 44, 47, 33]);
}

/** scanl

  scan left

  template <typename T, typename Acc>
  array<Acc> scanl(std::function<Acc(Acc, T)> f, Acc init, array<T>& src) {
    array<Acc> result(src.size() + 1);
    std::exclusive_scan(src.cbegin(), src.cend(), result.begin(), init, f);
    return result;
  }
*/

assert(scanl(\acc x.acc+x, 42, [1, 2, 3]), [42, 43, 45, 48])

/** foldlT2Step

  fold left from index `begin` over pairs

  template <typename T1, typename T2, typename Acc>
  U foldlT2Step(std::function<Acc(Acc, std::tuple<T1, T2>> f, Acc init, array<std::tuple<T1, T2>>& src, long begin) {
    return std::accumulate(src1.cbegin() + begin, src1.cend(), init, f);
  }
*/

assert(foldlT2Step(\acc a b.acc+a+b, 42, [(1, 2), (3, 4), (5, 6)], 1L), 42 + (3+4) + (5+6))

/** foldlT2

  fold left over pairs

  template <typename T1, typename T2, typename Acc>
  U foldlT2(std::function<Acc(Acc, std::tuple<T1, T2>> f, Acc init, array<std::tuple<T1, T2>>& src) {
    return std::accumulate(src.cbegin(), src.cend(), init, f);
  }
*/

assert(foldlT2(\acc a b.acc+a+b, 42, [(1, 2), (3, 4), (5, 6)]), 42 + (1+2) + (3+4) + (5+6))

/** foldlCT2Step

  just like `foldlT2Step`, but the predicate must be a closure
*/

assert(foldlCT2Step(toClosure(\x.x.0+(x.1*x.2)), 42, [(1, 2), (3, 4), (5, 6)], 1L), 42 + (3*4) + (5*6))

/** foldlCT2

  just like `foldlT2`, but the predicate must be a closure
*/

assert(foldlCT2(toClosure(\x.x.0+(x.1*x.2)), 42, [(1, 2), (3, 4), (5, 6)]), 42 + (1*2) + (3*4) + (5*6))

/** findIter

  find the first element in the array that satisfies the predicate, starts from `begin`, return `maybe<T>`

  template <typename T>
  maybe<T> findIter(std::function<bool(T)> f, array<T>& src, long begin) {
    const auto it = std::find_if(src.cbegin() + begin, src.cend(), f);
    return it == src.cend() ? nothing() : just(*it);
  }
*/

assert(findIter(\x.x > 3, [1..5], 0L), just(4))
assert(findIter(\x.x == 3, [1..5], 3L), nothing::maybeInt)

/** find

  find the first element in the array that satisfies the predicate, return `maybe<T>`

  template <typename T>
  maybe<T> find(std::function<bool(T)> f, array<T>& src) {
    const auto it = std::find_if(src.cbegin(), src.cend(), f);
    return it == src.cend() ? nothing() : just(*it);
  }
*/

assert(find(\x.x > 3, [1..5]), just(4))
assert(find(\x.x == 7, [1..5]), nothing::maybeInt)

/** countTrues

  count how many values in the array satisfy the predicate `f`, starts from `begin`

  template <typename T>
  long countTrues(std::function<bool(T)> f, long init, array<bool>& src, long begin) {
    return init + std::count_if(src.cbegin() + begin, src.cend(), f);
  }
*/

assert(countTrues(\x.x == 3, 42L, [3, 5, 3, 7, 3], 0L), 42L + 3L)
assert(countTrues(\x.x == 3, 42L, [3, 5, 3, 7, 3], 1L), 42L + 2L)
assert(countTrues(\x.x == 3, 42L, [1, 2, 4], 1L), 42L)


/** countTrue

  count the number of `true` in the array

  template <typename T>
  long countTrue(std::function<bool(T)> f, array<bool>& src) {
    return init + std::count_if(src.cbegin(), src.cend(), f);
  }
*/

assert(countTrue(\x.x == 3, [3, 5, 3, 7, 3]), 3L)
assert(countTrue(\x.x == 3, [1, 2, 4]), 0L)
assert(countTrue(\x.x == 3, []::[int]), 0L)

/** counts

  counts the total result of `f` on each element with initial value `init`, starts from `begin`

  template <typename T>
  long counts(std::function<bool(T)> f, long init, array<T>& src, long begin) {
    return std::accumulate(src.cbegin() + begin, src.cend(), init, f);
  }
*/

assert(counts(length, 42L, ["abc", "defg"], 0L), 42L + 7L)
assert(counts(length, 42L, ["abc", "defg"], 1L), 42L + 4L)

/** count

  counts the total result of `f` on each element with initial value `init`

  template <typename T>
  long count(std::function<bool(T)> f, array<T>& src) {
    return std::accumulate(src.cbegin() + begin, src.cend(), init, f);
  }
*/

assert(count(length, ["abc", "defg"]), 7L)
assert(count(length, ["abc", "defg"]), 7L)

/** sum

  sum the values in the array, starts from `begin`

  template <typename T>
  T sum(array<T>& src) {
    return std::accumulate(src.cbegin(), src.cend(), T{});
  }
*/

assert(sum([1..5]), 1 + 2 + 3 + 4 + 5)
assert(sum([]::[int]), 0)

/** rangeInto

  copy integers from `low` to `high` (inclusive) to array `dst` starts from `begin`

  template <typename T>
  array<T> rangeInto(T low, T high, array<T>& dst, long begin) {
    std::iota(dst.begin() + begin, dst.begin() + begin + (high - low + 1), low);
  }
*/

do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(rangeInto(1, 5, b, 0L), [1..5]);
}
do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(rangeInto(1, 5, b, 1L), [33, 1, 2, 3, 4]);
}
do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(rangeInto(1, 0, b, 2L), [33, 33, 33, 33, 33]);
}

/** range

  create an array of integers from `begin` to `end` (inclusive)

  template <typename T>
  array<T> range(T low, T high) {
    array<T> result(high - low + 1);
    std::iota(result.begin(), result.end(), low);
    return result;
  }
*/

assert(range(1, 5), [1..5])
assert(range(1, 0), []::[int])

/** arepeat

  fill `dst` with `value` starts from `begin`

  template <typename T>
  array<T> arepeat(T value, long begin, array<T>& dst) {
    for (long i = 0; i < n; ++i) {
      dst[i] = value;
    }
    return dst;
  }
*/

do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(arepeat(1, 0L, b), [1, 1, 1, 1, 1]);
}
do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(arepeat(1, 1L, b), [33, 1, 1, 1, 1]);
}

/** repeat

  create an array of `value` with length `n`

  template <typename T>
  array<T> repeat(T value, long n) {
    array<T> result(n);
    for (long i = 0; i < n; ++i) {
      result[i] = value;
    }
    return result;
  }
*/

assert(repeat(1, 5L), [1, 1, 1, 1, 1])
assert(repeat(1, 0L), []::[int])

/** max

  compare two values and return the larger one

  template <typename T>
  T max(T a, T b) {
    return std::max(a, b);
  }

  ** IMPORTANT **

  `max` and `min` works differently in C++, see [alg.sorting.general]/5:

  > A sequence is sorted if, for every iterator `i` and non-negative integer `n`, `*(i+n) < *i` is `false`

  that is, if `x` == `y`, then `std::min(x, y) == x` and `std::max(x, y) == y`,
  however, in hobbes, `min(x, y) == y` and `max(y, y) `.  Theirs stability pereferences are different
*/

assert(max(1, 2), 2)

/** min

  compare two values and return the smaller one

  template <typename T>
  T min(T a, T b) {
    return std::min(a, b);
  }

  see ** IMPORTANT ** note in `max`
*/

assert(min(1, 2), 1)

/** maximum

  find the largest value which is larger than `value` in the array, otherwise return `value`

  template <typename T>
  T maximum(T value, array<T>& src) {
      const auto v = std::max_element(src.cbegin(), src.cend());
      return value > v ? value : v;
  }
*/

assert(maximum(1, [1..5]), 5)
assert(maximum(6, [1..5]), 6)

/** minumum

  find the smallest value which is smaller than `value` in the array, otherwise return `value`

  template <typename T>
  T minimum(T value, array<T>& src) {
      const auto v = std::min_element(src.cbegin(), src.cend());
      return value < v ? value : v;
  }
*/

assert(minimum(1, [1, 2, 0, 4, 5]), 0)
assert(minimum(6, [7, 8]), 6)

/** normIdx

  normalize an index to be in the range of [0, size]. Used for slicing, clamp the index to the range of [0, size)

  template <typename T, typename I>
  T normIdx(array<T>& src, I idx) {
    return idx < 0 ? std::max(idx + size, 0) : std::min(idx, src.size());
  }
*/

assert(normIdx([1..5], 0), 0)
assert(normIdx([1..5], 1), 1)
assert(normIdx([1..5], 5), 5)
assert(normIdx([1..5], 6), min(5L, 6L))
assert(normIdx([1..5], -1), max(0L, 5L-1L))
assert(normIdx([1..5], -6), max(0L, 5L-6L))

/** slice

  slice an array with `start` and `end` index

  if index is negative, it will be normalized to be in the range of [0, size] by `normIdx`

  after normalization, if `start` >= `end`, returns a reversed `slice(array, end, start)`
*/

do {
  b = [1..5];
  assert(slice(b, 0, 5), [1..5]);
  assert(slice(b, 1, 3), [2, 3]);
  assert(slice(b, 1, -1), slice(b, 1, 5-1));
  assert(slice(b, -2, -1), slice(b, 5-2, 5-1));
  assert(slice(b, -2, 7), slice(b, 5-2, 5));
  assert(slice(b, 7, -2), reverse(slice(b, 5-2, 5)));
}

/** cdelim

  join an array of string with a delimiter

  array<string> cdelim(array<string>& src, string delim) {
    array<string> result;
    for (long i = 0; i <= src.size() - 1; ++i) {
      result.copy(src[i].cbegin(), src[i].cend(), std::back_inserter(result));
      result.copy(delim.cbegin(), delim.cend(), std::back_inserter(result));
    }
    if (src.size() > 0) {
      result.copy(src.back().cbegin(), src.back().cend(), std::back_inserter(result));
    }
    return result;
  }
*/

assert(cdelim(["a", "b", "c"], ","), "a,b,c")
assert(cdelim(["a", "b", "c"], ""), "abc")
assert(cdelim(["abc", "bcd", "cdefg"], "<->"), "abc<->bcd<->cdefg")

/** zip

  zip two arrays into an array of pairs

  template <typename T, typename U>
  array<pair<T, U>> zip(array<T>& a, array<U>& b) {
    array<std::pair<T, U>> result;
    std::transform(a.cbegin(), a.cbegin() + std::min(a.size(), b.size()), b.cbegin(), std::back_inserter(result), [](T x, U y) {
      return std::make_pair(x, y);
    });
    return result;
  }
*/

assert(zip([1, 2, 3], [4, 5, 6]), [(1, 4), (2, 5), (3, 6)])
assert(zip([1, 2, 3], [4, 5]), [(1, 4), (2, 5)])
assert(zip([1, 2], [4, 5, 6]), [(1, 4), (2, 5)])

/** zipWith

  zip two arrays into an array of pairs, and apply a function `f` to each pair

  template <typename T, typename U, typename R>
  array<R> zipWith(std::function<R(T, U)> f, array<T>& a, array<U>& b) {
    array<R> result;
    std::transform(a.cbegin(), a.cbegin() + std::min(a.size(), b.size()), b.cbegin(), std::back_inserter(result), f);
    return result;
  }
*/

assert(zipWith(\x y.x+y, [1, 2, 3], [4, 5, 6]), [5, 7, 9])
assert(zipWith(\x y.x+y, [1, 2, 3], [4, 5]), [5, 7])
assert(zipWith(\x y.x+y, [1, 2], [4, 5, 6]), [5, 7])

/** unzipStep

  unzip an array of pairs into two arrays, all arrays start with index `begin` and end with index `end`

  template <typename T, typename U>
  void unzipStep(array<std::pair<T, U>>& src, array<T>& a, array<U>& b, long begin, long end) {
    while (begin < src.size()) {
      a[begin](s[begin].first);
      b[begin](s[begin].second);
      ++begin;
    }
  }
*/

do {
  a = [1, 2, 3];
  b = [4, 5, 6];
  c = zip(a, b);

  a1 = newArray(size(a));
  copy(a1, 0L, [33, 33, 33]);
  b1 = newArray(size(b));
  copy(b1, 0L, [44, 44, 44]);

  unzipStep(c, a1, b1, 0L, size(c));
  assert(a1, a);
  assert(b1, b);

  copy(a1, 0L, [33, 33, 33]);
  copy(b1, 0L, [44, 44, 44]);
  unzipStep(c, a1, b1, 1L, size(c)-1);
  assert(a1, [33, 2, 33]);
  assert(b1, [44, 5, 44]);
}

/** unzip

  unzip an array of pairs into two arrays

  template <typename T, typename U>
  std::pair<array<T>, array<U>> unzip(array<std::pair<T, U>>& src) {
    array<T> a;
    array<U> b;
    for (const auto& s: src) {
      a.push_back(s.first);
      b.push_back(s.second);
    }
    return std::make_pair(a, b);
  }
*/

assert(unzip([(1, 4), (2, 5), (3, 6)]), ([1, 2, 3], [4, 5, 6]))
assert(unzip([(1, 4), (2, 5)]), ([1, 2], [4, 5]))

/** ArrayIndex

  arrayIndexFrom: anything that can be converted to long
*/

assert(arrayIndexFrom(42L), 42L)
assert(arrayIndexFrom(42), 42L)
assert(arrayIndexFrom(42S), 42L)
assert(arrayIndexFrom(0X2A), 42L)

/** Function

  apply: apply a function to a value
*/

assert(apply(\x.x+1, 42), 43)
assert(apply(toClosure(\x.x+1), 42L), 43L)

/** toClosure

  convert a function to a closure
*/

assert(apply(toClosure(\x.x+1), 42), 43)

/** atm

  get a maybe value from an array at `index`

  template <template <typename> Array, typename I>
  maybe<T> atm(Array& src, I index) {
    const long i = index;
    if (i > src.size() - 1 || i < 0) {
      return nothing();
    }
    return just(src[i]);
  }
*/

assert(atm([1..5], 0L), just(1))
assert(atm([1..5], -1L), nothing::maybeInt)
assert(atm([1..5], 10L), nothing::maybeInt)

/** atMay

  like `atm`, but only works on `array<T>`
*/

assert(atMay([1..5], 0L), just(1))
assert(atMay([1..5], -1L), nothing::maybeInt)
assert(atMay([1..5], 10L), nothing::maybeInt)

/** headMay

  get the first element of an array, return `maybe<T>`

  template <typename T>
  maybe<T> headMay(array<T>& src) {
    if (src.size() == 0) {
      return nothing();
    }
    return just(src[0]);
  }
*/

assert(headMay([1..5]), just(1))
assert(headMay([]::[int]), nothing::maybeInt)

/** tailMay

  get the last element of an array, return `maybe<T>`

  template <typename T>
  maybe<T> tailMay(array<T>& src) {
    if (src.size() == 0) {
      return nothing();
    }
    return just(src[src.size() - 1]);
  }
*/

assert(tailMay([1..5]), just([2..5]))
assert(tailMay([1]), just([]::[int]))
assert(tailMay([]::[int]), nothing::maybeInt)

/** justOne

  get the only element of an array, return `maybe<T>`

  template <typename T>
  maybe<T> justOne(array<T>& src) {
    if (src.size() != 1) {
      return nothing();
    }
    return just(src[0]);
  }
*/

assert(justOne([1..5]), nothing::maybeInt)
assert(justOne([1]), just(1))
assert(justOne([]::[int]), nothing::maybeInt)

/** justFist

  get the first element of an array, return `maybe<T>`

  template <typename T>
  maybe<T> justFirst(array<T>& src) {
    if (src.size() == 0) {
      return nothing();
    }
    return just(src[0]);
  }
*/

assert(justFirst([1..5]), just(1))
assert(justFirst([1]), just(1))
assert(justFirst([]::[int]), nothing::maybeInt)

/** justLast

  get the last element of an array, return `maybe<T>`

  template <typename T>
  maybe<T> justLast(array<T>& src) {
    if (src.size() == 0) {
      return nothing();
    }
    return just(src[src.size() - 1]);
  }
*/

assert(justLast([1..5]), just(5))
assert(justLast([1]), just(1))
assert(justLast([]::[int]), nothing::maybeInt)

/** Array

  size: number of elements in an array
  element: element at index
  elementM: maybe element at index
  elements: range of elements
*/

assert(size([1..3]), 3L)
assert(element([1..3], 1L), 2)
assert(elementM([1..3], 1L), just(2))
assert(elementM([1..3], 100L), nothing::maybeInt)
assert(elements([1..3], 1L, 3L), [2, 3])
// TODO: what's the proper behavior here?
//assert(elements([1..3], 1L, 5L), [2, 3])

/** Convert a -> b
  
  convert: convert a value to another type
*/

/// Convert long long
assert(convert(42L)::long, 42L)

/// Convert [a] [b]
assert(convert([3S, 4S])::[int], [3, 4])

/** selectElementsInto

  using function `f` to map elements from `src` at [`begin`, `end`),
  into `dst` starts from `dstBegin`, with step `dstStep`

  template <typename T, typename U>
  array<T> selectElementsInto(
          array<T>& src,
          std::function<U(array<T>&, long)> f,
          long begin, long end,
          array<U>& dst, long dstBegin, long dstStep) {
    for (; begin < end; ++begin, dstBegin += dstStep) {
      dst[dstBegin](f(src, begin));
    }
    return dst;
  }
*/

do {
  a = [1..5];
  b = newArray(5L);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(selectElementsInto(a, \xs i.xs[i]+1, 0L, 5L, b, 0L, 1L), [2, 3, 4, 5, 6]);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(selectElementsInto(a, \xs i.xs[i]+1, 1L, 4L, b, 0L, 1L), [3, 4, 5, 33, 33]);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(selectElementsInto(a, \xs i.xs[i]+1, 1L, 3L, b, 1L, 2L), [33, 3, 33, 4, 33]);
}

/** verifybound

  verify that `begin` and `end` are in the range of [0, limit]

  template <typename T>
  maybe<std::tuple<array<T>&, long, long>>
  verifybound(array<T>& src, long limit, long begin, long end) {
    if (end < begin() || limit < end || begin < 0) {
      return nothing();
    }
    return just(std::tuple(src, begin, end));
  }
*/

assert(isNothing(verifybound([1..5], 3L, -1L, 5L)), true)
assert(isNothing(verifybound([1..5], 3L, 2L, 4L)), true)
assert(isNothing(verifybound([1..5], 3L, 4L, 2L)), true)
assert(verifybound([1..5], 4L, 1L, 4L), just(([1..5], 1L, 4L)))
assert(verifybound([1..5], 5L, 1L, 4L), just(([1..5], 1L, 4L)))
assert(verifybound([1..5], 5L, 4L, 4L), just(([1..5], 4L, 4L)))

/** defElementsWith

  if `begin` and `end` are in the range of [0, limit], then returns a new array with `f` applied to each element of `src`,
  otherwise return an empty array

  template <typename T, typename U>
  array<U> defElementsWith(array<T>& src, long limit, std::function<U(array<T>&, long)> f, long begin, long end) {
    if (end < begin() || limit < end || begin < 0) {
      return array<U>();
    }
    array<U> dst(end - begin);
    for (long i = 0; begin < end; ++begin, ++i) {
      dst[i](f(src, begin));
    }
    return dst;
  }
*/

assert(defElementsWith([1..5], 3L, \xs i.xs[i]+1, -1L, 5L), []::[int])
assert(defElementsWith([1..5], 3L, \xs i.xs[i]+1, 2L, 4L), []::[int])
assert(defElementsWith([1..5], 3L, \xs i.xs[i]+1, 0L, 2L), [2, 3])

/** getElementByIndex

  if `index` is in the range of [0, size), then returns `just(f(src, index))`, otherwise return `nothing()`

  template <typename T, typename U>
  maybe<U> getElementByIndex(array<T>& src, std::function<U(array<T>&, long)> f, long index, long len) {
    return (index < src.size() && index >= 0) ? just(f(src[i])) : nothing();
  }
*/

assert(getElementByIndex([1..5], \xs i.xs[i]+1, 0L, 5L), just(2))
assert(getElementByIndex([1..5], \xs i.xs[i]+1, 1L, 5L), just(3))
assert(getElementByIndex([1..5], \xs i.xs[i]+1, 5L, 5L), nothing::maybeInt)
assert(getElementByIndex([1..5], \xs i.xs[i]+1, -1L, 5L), nothing::maybeInt)

/** Array xs x | xs -> x

  size: number of elements in an array
    template <typename T>
    long size(array<T>& src) {
      return src.size();
    }

  element: element at index
    template <typename T>
    T element(array<T>& src, long index) {
      return src[index];
    }

  elementM: maybe element at `index`
    template <typename T>
    maybe<T> elementM(array<T>& src, long index) {
      return (index < src.size() && index >= 0) ? just(src[index]) : nothing();
    }

  elements: range of elements within [`begin`, `end`] if the range is valid
    template <typename T>
    array<T> elements(array<T>& src, long begin, long end) {
      return defElementsWith(src, src.size(), [](array<T>& xs, long i) { return xs[i]; }, begin, end);
    }
*/

/// Array [a] a
assert(size([1..3]), 3L)
assert(element([1..3], 1L), 2)
assert(elementM([1..3], 1L), just(2))
assert(elementM([1..3], 100L), nothing::maybeInt)
assert(elements([1..3], 1L, 3L), [2, 3])
assert(elements([1..3], 1L, 4L), []::[int])

/// Array [:char|n:] char
do {
  a = newPrimZ()::[:char|42:];
  saacopy(a, "hello", 5L);

  assert(size(a), 5L); // null-terminated string
  assert(element(a, 1L), 'e');
  assert(elementM(a, 1L), just('e'));
  assert(elementM(a, 100L), nothing::maybeChar);
  assert(elements(a, 1L, 3L), "el");
  assert(elements(a, 1L, 100L), []::[char]);
}

/// Array [:a|n:] a
do {
  a = newPrimZ()::[:int|42:];
  saacopy(a, [1..5], 5L);

  assert(size(a), 42L); // full length
  assert(element(a, 1L), 2);
  assert(elementM(a, 1L), just(2));
  assert(elementM(a, 100L), nothing::maybeInt);
  assert(elements(a, 1L, 3L), [2, 3]);
  assert(elements(a, 1L, 100L), []::[int]);
}

/// Array std::string char
assert(size(aStdString), 11L)
assert(element(aStdString, 1L), 'e')
assert(elementM(aStdString, 1L), just('e'))
assert(elementM(aStdString, 100L), nothing::maybeChar)
assert(elements(aStdString, 1L, 3L), "el")
assert(elements(aStdString, 1L, 100L), []::[char])

/// Array char* char
assert(size(aCStr), 5L)
assert(element(aCStr, 1L), 'e')
assert(elementM(aCStr, 1L), just('e'))
assert(elementM(aCStr, 100L), nothing::maybeChar)
assert(elements(aCStr, 1L, 3L), "el")
assert(elements(aCStr, 1L, 100L), []::[char])

/// Array (char* * long) char
do {
  a = (aCStr, 5L);
  assert(size(a), 5L);
  assert(element(aCStr, 1L), 'e');
  assert(elementM(aCStr, 1L), just('e'));
  assert(elementM(aCStr, 100L), nothing::maybeChar);
  assert(elements(aCStr, 1L, 3L), "el");
  assert(elements(aCStr, 1L, 100L), []::[char]);
}

/// Array (long * char*) char
do {
  a = (5L, aCStr);
  assert(size(a), 5L);
  assert(element(aCStr, 1L), 'e');
  assert(elementM(aCStr, 1L), just('e'));
  assert(elementM(aCStr, 100L), nothing::maybeChar);
  assert(elements(aCStr, 1L, 3L), "el");
  assert(elements(aCStr, 1L, 100L), []::[char]);
}

// TODO: Array a@f e

/// Array (vector t s n) t
assert(size(aVec), 10L)
assert(element(aVec, 1L), 1)
assert(elementM(aVec, 1L), just(1))
assert(elementM(aVec, 100L), nothing::maybeInt)
assert(elements(aVec, 1L, 3L), [1, 2])
assert(elements(aVec, 1L, 100L), []::[int])

/** reverse

  return a new copy of reversed `src`

  template <typename T>
  array<T> reverse(array<T>& src) {
    array<T> result(src.size());
    std::reverse_copy(src.cbegin(), src.cend(), result.begin());
    return result;
  }
*/

assert(reverse([1..5]), [5, 4, 3, 2, 1])

// TODO: ArrayView t a

/** fstrlen

  find the length of a possible null-terminated fix size char array

  template <typename T>
  long fstrlen(array<T>& s, long begin) {
    for (; begin < s.size(); ++begin) {
      if (s[begin] == '\0') {
        return begin;
      }
    }
    return s.size();
  }
*/

do {
  a = newPrimZ()::[:char|5:];
  saacopy(a, "hello", 5L);
  assert(fstrlen(a, 0L), 5L);
}
do {
  a = newPrimZ()::[:char|42:];
  saacopy(a, "hello", 5L);
  assert(fstrlen(a, 0L), 5L);
}

/** bvInit

  initialize an array of `T` with `value` from `index`

  void bvInit(array<byte>& src, long index, byte value) {
    std::fill(src.begin() + index, src.end(), value);
  }
*/

do {
  a = newArray(3L)::[byte];
  copy(a, 0L, [0X12, 0X34, 0X56]);
  bvInit(a, 1L, 0X78);
  assert(a, [0X12, 0X78, 0X78]);
}

/** newBitvec

  create a new bitvec with `size` bits

  bitvec newBitvec(long size) {
    array<byte> result(1 + (n - 1) / 8) + 1); // first byte for the remainder
    result[0] = n % 8;
    return result;
  }
*/

assert(convert(newBitvec(42L))::[byte], [0X02, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00]) // 2 as remainder + 8x6 to contain 42 bits

/** bvLength

  return the length of a bitvec

  long bvLength(bitvec& src) {
    if (src[0] == 0) {
      return src.size() * 8;
    }
    return (src.size() - 1) * 8 + src[0];
  }
*/

assert(bvLength(newBitvec(42L)), 42L)
assert(bvLength(newBitvec(8L)), 8L)
assert(bvLength(newBitvec(40L)), 40L)

/** bvIsSet

  return true if the bit at `index` is set

  bool bvIsSet(bitvec& src, long index) {
    return (src[index / 8 + 1] & (1 << (index % 8))) != 0;
  }
*/

do {
  a = newBitvec(3L);
  assert(bvIsSet(a, 0L), false);
  bvSet(a, 0L, true);
  assert(bvIsSet(a, 0L), true);
}

/** bvSet

  set the bit at `index` to `value`

  void bvSet(bitvec& src, long index, bool value) {
    if (value) {
      src[index / 8 + 1] |= (1 << (index % 8));
    } else {
      src[index / 8 + 1] &= ~(1 << (index % 8));
    }
  }
*/

do {
  a = newBitvec(13L);
  bvSet(a, 1L, true);
  assert(convert(a)::[byte], [0X05, 0X02, 0X00]);
  bvSet(a, 1L, false);
  assert(convert(a)::[byte], [0X05, 0X00, 0X00]);
}

/** bvPrintT

  print a bitvec to stdout, range from [begin, end)

  *higher bits get printed first*

  void bvPrintT(bitvec& src, long begin, long end) {
    for (long i = bvLength(src); i > 0; ++i) {
      std::cout << (bvIsSet(src, i-1) ? "1" : "0");
    }
    std::cout << std::endl;
  }
*/

do {
  a = newBitvec(13L);

  captureStdout();
  bvPrintT(a, 0L, bvLength(a));
  assert(releaseStdout(), "0000000000000");

  bvSet(a, 1L, true);
  captureStdout();
  bvPrintT(a, 0L, bvLength(a));
  assert(releaseStdout(), "0100000000000");

  captureStdout();
  bvPrintT(a, 1L, bvLength(a));
  assert(releaseStdout(), "100000000000");

  bvSet(a, 9L, true);
  captureStdout();
  bvPrintT(a, 0L, bvLength(a));
  assert(releaseStdout(), "0100000001000");
}

/** wherePs

  start from the `index` of both `src` and `dst`, set the value of `dst` to the result of predicate `f`

  template <typename T>
  bitvec& wherePs(std::function<bool(T)> f, array<T>& src, bitvec& dst, long index) {
    std::transform(src.cbegin() + index, src.cend(), dst.begin() + index, f);
    return dst;
  }
*/

do {
  a = [1..5];
  b = newBitvec(5L);
  wherePs(\x.x%2==0, a, 0L, b);
  assert(convert(b)::[byte], [0X05, 0X0A]); // 1010
}

/** whereP

  return a bitvec based on the predicate `f` applied to each element of `src`

  template <typename T>
  bitvec whereP(std::function<bool(T)> f, array<T>& src) {
    bitvec result = newBitvec(src.size());
    std::transform(src.cbegin(), src.cend(), result.begin(), f);
    return result;
  }
*/

do {
  a = [1..5];
  b = whereP(\x.x%2==0, a);
  assert(convert(b)::[byte], [0X05, 0X0A]); // 1010
}

/** bvCount8

  count the number of bits set in a byte

  long bvCount8(byte b) {
    long result = 0;
    for (long i = 0; i < 8; ++i) {
      result += (b & (1 << i)) != 0;
    }
    return result;
  }
*/

assert(bvCount8(0X00), 0L)
assert(bvCount8(0X02), 1L)
assert(bvCount8(0X03), 2L)
assert(bvCount8(0X33), 4L)
assert(bvCount8(0Xff), 8L)

/** selectStep

  select elements from `src` at indices from `indices` into `dst`, starts from `begin`

  template <typename T>
  void selectStep(array<T>& src, array<long>& indices, array<T>& dst, long begin) {
    std::transform(indices.cbegin() + begin, indices.cend(), dst.begin() + begin, [&src](long i) { return src[i]; });
  }
*/

do {
  a = [1..5];
  b = [0L, 2L, 4L];
  c = newArray(3L);
  selectStep(a, b, c, 0L);
  assert(c, [1, 3, 5]);
}
do {
  a = [1..5];
  b = [0L, 2L, 4L];
  c = newArray(3L);
  copy(c, 0L, [33, 33, 33]);
  selectStep(a, b, c, 1L);
  assert(c, [33, 3, 5]);
}

/** select

  select elements from `src` at indices from `indices`

  template <typename T>
  array<T> select(array<T>& src, array<long>& indices) {
    array<T> result(indices.size());
    std::transform(indices.cbegin(), indices.cend(), result.begin(), [&src](long i) { return src[i]; });
    return result;
  }
*/

do {
  a = [1..5];
  b = [0L, 2L, 4L];
  assert(select(a, b), [1, 3, 5]);
}

/** selectBStep

  select from `src` at indices from `indices`, both starts from `begin` to `end`, into `dst` starts from `dstBegin`

  template <typename T, template<typename T> Array>
  void selectBStep(Array& src, bitvec& indices, long begin, long end, array<T>& dst, long dstBegin) {
    std::transform(indices.cbegin() + begin, indices.cend(), dst.begin() + dstBegin, [&src](long i) { return src[i]; });
  }
*/

do {
  a = [1..5];
  b = newBitvec(5L);
  bvSet(b, 0L, true);
  bvSet(b, 2L, true);
  bvSet(b, 4L, true);
  c = newArray(3L);
  selectBStep(a, b, 0L, 5L, c, 0L);
  assert(c, [1, 3, 5]);
}
do {
  a = [1..5];
  b = newBitvec(5L);
  bvSet(b, 0L, true);
  bvSet(b, 2L, true);
  bvSet(b, 4L, true);
  c = newArray(2L);
  copy(c, 0L, [33, 33]);
  selectBStep(a, b, 1L, 4L, c, 1L);
  assert(c, [33, 3]);
}

/** selectB

  select from `src` at indices from `indices`

  template <typename T, template<typename T> Array>
  array<T> selectB(Array& src, bitvec& indices) {
    array<T> result(src.size());
    std::transform(indices.cbegin(), indices.cend(), result.begin(), [&src](long i) { return src[i]; });
    return result;
  }
*/

do {
  a = [1..5];
  b = newBitvec(5L);
  bvSet(b, 0L, true);
  bvSet(b, 2L, true);
  bvSet(b, 4L, true);
  assert(selectB(a, b), [1, 3, 5]);
}

/** selectRStep

  select elements from `src` at [`begin`, `end`), to `dst` starts at `dstBegin`

  template <typename T>
  void selectRStep(array<T>& src, array<T>& dst, long dstBegin, long begin, long end) {
    std::copy(src.cbegin() + begin, src.cend() + end, dst.begin() + dstBegin);
  }
*/

do {
  a = [1..5];
  b = newArray(3L);
  copy(b, 0L, [33, 33, 33]);
  selectRStep(a, b, 1L, 1L, 3L);
  assert(b, [33, 2, 3]);
}

/** selectRange

  select elements from `src` at [`begin`, `end`)

  template <typename T>
  array<T> selectRange(array<T>& src, long begin, long end) {
    const auto hi = std::min(src.size(), end);
    const auto lo = std::max(0L, begin);
    if (hi <= lo) {
      return {};
    }
    array<T> result(hi - lo);
    std::copy(src.cbegin() + lo, src.cend() + hi, result.begin());
    return result;
  }
*/

do {
  a = [1..5];
  assert(selectRange(a, 1L, 3L), [2, 3]);
  assert(selectRange(a, 1L, 1L), []::[int]);
  assert(selectRange(a, 1L, 0L), []::[int]);
  assert(selectRange(a, 1L, -1L), []::[int]);
  assert(selectRange(a, 1L, 100L), [2, 3, 4, 5]);
  assert(selectRange(a, 100L, 100L), []::[int]);
  assert(selectRange(a, -100L, 100L), a);
}

/** selectKeyStep

  for a sorted array `m` with type [(K, V)] starts from `mStart`, and a sorted array `keys` with type [K] starts from `keyStart`,
  select all elements from `m` that has a key in `keys` into `result` starts from `resultStart`

  template <typename K, typename V>
  long selectKeyStep(array<std::pair<K, V>>& m, long mStart, array<K>& keys, long keyStart, array<std::pair<K, V>>& result, long resultStart) {
    if (mStart >= m.size() || keyStart >= keys.size()) {
      return keyStart;
    }
    if (m[mStart].first < keys[keyStart]) {
      return selectKeyStep(m, mStart + 1, keys, keyStart, result, resultStart);
    }
    if (keys[keyStart] < m[mStart].first) {
      return selectKeyStep(m, mStart, keys, keyStart + 1, result, resultStart);
    }
    result[resultStart] = m[mStart];
    return selectKeyStep(m, mStart + 1, keys, keyStart + 1, result, resultStart + 1);
  }
*/

do {
  a = [(1, 1), (1, 2), (2, 2), (4, 4), (5, 5)];
  b = [1, 3, 5, 6];
  c = newArray(3L);
  assert(selectKeyStep(a, 0L, b, 0L, c, 0L), 3L);
  assert(c, [(1, 1), (5, 5)]);
}

/** selectKeys

  for a sorted array `m` with type [(K, V)], and a sorted array `keys` with type [K],
  select all elements from `m` that has a key in `keys`

  template <typename K, typename V>
  array<std::pair<K, V>> selectKeys(array<std::pair<K, V>>& m, array<K>& keys) {
    array<std::pair<K, V>> result(std::min(m.size(), keys.size()));
    selectKeyStep(m, 0L, keys, 0L, result, 0L);
    return result;
  }
*/

do {
  a = [(1, 1), (1, 2), (2, 2), (3, 3), (4, 4), (5, 5)];
  b = [1, 3, 5];
  assert(selectKeys(a, b), [(1, 1), (3, 3), (5, 5)]);
}

/** selectKeysFrom

  for a sorted array `m` with type [(K, V)], and a sorted array `keys` with type [K],
  select all elements from `m` that has a key in `keys` starts from `begin`

  template <typename K, typename V>
  std::pair<long, array<std::pair<K, V>>> selectKeysFrom(array<std::pair<K, V>>& m, array<K>& keys, long begin) {
    array<std::pair<K, V>> result(std::min(m.size(), keys.size()));
    const auto n = selectKeyStep(m, begin, keys, 0L, result, 0L);
    return {n, result};
  }
*/

do {
  a = [(1, 1), (1, 2), (2, 2), (4, 4), (5, 5)];
  b = [1, 3, 5, 6];
  assert(selectKeysFrom(a, b, 0L), (3L, [(1, 1), (5, 5)]));
  assert(selectKeysFrom(a, b, 2L), (3L, [(5, 5)]));
  assert(selectKeysFrom(a, b, 3L), (3L, []::[(int * int)]));
}

/** filter

  return a new array with elements from `src` that satisfy the predicate `f`

  template <typename T>
  array<T> filter(std::function<bool(T)> f, array<T>& src) {
    array<T> result(src.size());
    auto it = std::copy_if(src.cbegin(), src.cend(), result.begin(), f);
    return result;
  }
*/

assert(filter(\x.x%2==0, [1..5]), [2, 4])
assert(filter(\x.x%2==0, [1, 3, 5]), []::[int])

/** filterMapStep

  for each element in `src` starts from `begin`, apply `f`, and write to `result`,
  returns how many values are written to `result` that is not `nothing()`

  template <typename T, typename U>
  long filterMapStep(std::function<maybe<U>(T)> f, array<T>& src, begin, array<maybe<U>>& result, long init) {
    for (; begin < src.size(); ++begin) {
      result[init] = f(src[begin]);
      if (r.isJust()) {
        ++init;
      }
    }
    return init;
  }
*/

do {
  b = newArray(5L);
  assert(filterMapStep(\x.if x%2==0 then just(x) else nothing, [1..5], 0L, b, 0L), 2L);
  assert(b, [nothing, just(2), nothing, just(4), nothing]);
}

/** selectJust

  select all `just` values from `src` stars from `begin`, into `dst` starts from `dstBegin`

  template <typename T>
  array<T>& selectJust(array<maybe<T>>& src, long begin, array<T>& dst, long dstBegin) {
    for (; begin < src.size(); ++begin) {
      if (src[begin].isJust()) {
        dst[dstBegin++] == src[begin].value();
      }
    }
    return dst;
  }
*/

assert(selectJust([nothing, just(3), nothing, just(4), nothing], 0L, newArray(2L), 0L), [3, 4])

/** filterMap

  template <typename T, typename U>
  array<U> filterMap(std::function<maybe<U>(T)> f, array<T>& src) {
    array<U> result;
    result.reserve(src.size());
    for (auto& x : src) {
      const auto r = f(x);
      if (r.isJust()) {
        result.push_back(r.value());
      }
    }
    return result;
  }
*/

assert(filterMap(\x.if x%2==0 then just(x) else nothing, [1..5]), [2, 4])
assert(filterMap(\x.if x%2==0 then just(x) else nothing, [1, 3, 5]), []::[int])

/** fmapArrStep

  for each element in `src` starts from `begin`, apply `f`, and write to `dst` starts from `begin` as well

  template <typename T, template <typename> Array, typename U>
  array<U> fmapArrStep(std::function<U(T)> f, Array<T>& src, long begin, array<U>& dst) {
    std::transform(src.cbegin() + begin, src.cend(), result.begin() + begin, f);
    return dst;
  }
*/

assert(fmapArrStep(\x.x*2, [1..5], 0L, newArray(5L)), [2, 4, 6, 8, 10])

/** Map

  fmap: map a function over a container
*/

/// Map (a -> b, [a]) -> [b]
assert(fmap(\x.x*2, [1..5]), [2, 4, 6, 8, 10])

/// Map (a -> b, (()+a)) -> (()+b)
assert(fmap(\x.x*2, just(3)), just(6))
assert(fmap(\x.x*2, nothing::maybeInt), nothing::maybeInt)

/// Map (a -> b, (c+a)) -> (c+b)
assert(fmap(\x.x*2, |1=3|::(long+int)), |1=6|::(long+int))
assert(fmap(\x.x*2, |0=42L|::(long+int)), |0=42L|::(long+int))

/** ffilterArrStep

  for each element in `src` starts from `begin`, apply `f`, and set the bit at the same index in `dst`

  template <template <typename> Array, typename T>
  bitvec& ffilterArrStep(std::function<bool(T)> f, Array<T>& src, long begin, bitvec& dst) {
    std::transform(src.cbegin() + begin, src.cend(), dst.begin() + begin, f);
    return dst;
  }
*/

assert(convert(ffilterArrStep(\x.x%2==0, [1..5], 0L, newBitvec(5L)))::[byte], [0X05, 0X0A]) // 1010

/** FilterMap

  ffilterMap: filter a container with a predicate, and map a function over the result
*/

/// FilterMap (a -> bool, a -> b, [a]) -> [b]
assert(ffilterMap(\x.x%2==0, \x.x*2, [1..5]), [4, 8])

/// FilterMap (a -> bool, a -> b, (()+a)) -> (()+b)
assert(ffilterMap(\x.x%2==0, \x.x*2, just(4)), just(8))
assert(ffilterMap(\x.x%2==0, \x.x*2, just(3)), nothing::maybeInt)

/// FilterMap (a -> bool, a -> b, (c+a)) -> (c+b)
assert(ffilterMap(\x.x%2==0, \x.x*2, |1=3|::(long+int)), |0=def::long|::(long+int))
assert(ffilterMap(\x.x%2==0, \x.x*2, |1=4|::(long+int)), |1=8|::(long+int))
assert(ffilterMap(\x.x%2==0, \x.x*2, |0=42L|::(long+int)), |0=42L|::(long+int))

/** ffilterMMapStep

  for each element in `src` starts from `begin`, apply `f`, and write to `dst` starts from `begin` as well,
  return how many values are written to `dst` that is not `nothing()`

  template <template <typename> Array, typename T, typename U>
  long ffilterMMapStep(std::function<maybe<U>(T)> f, Array<T>& src, long begin, array<maybe<U>>& dst, long init) {
    for (; begin < src.size(); ++begin) {
      dst[init] = f(src[begin]);
      if (dst[init].isJust()) {
        ++init;
      }
    }
    return init;
  }
*/

do {
  b = newArray(5L);
  assert(ffilterMMapStep(\x.if x%2==0 then just(x) else nothing, [1..5], 0L, b, 0L), 2L);
  assert(b, [nothing, just(2), nothing, just(4), nothing]);
}

/** FilterMMap
  
    ffilterMMap: filter a container with a predicate, and map a function over the result
*/

/// FilterMMap (a -> (()+b), [a]) -> [b]
assert(ffilterMMap(\x.if x%2==0 then just(x) else nothing, [1..5]), [2, 4])

/// FilterMMap (a -> (()+b), (()+a)) -> (()+b)
assert(ffilterMMap(\x.if x%2==0 then just(x) else nothing, just(4)), just(4))
assert(ffilterMMap(\x.if x%2==0 then just(x) else nothing, just(3)), nothing::maybeInt)

/// FilterMMap (a -> (()+b), (c+a)) -> (c+b)
assert(ffilterMMap(\x.if x%2==0 then just(x) else nothing, |1=3|::(long+int)), |0=def::long|::(long+int))
assert(ffilterMMap(\x.if x%2==0 then just(x) else nothing, |1=4|::(long+int)), |1=4|::(long+int))
assert(ffilterMMap(\x.if x%2==0 then just(x) else nothing, |0=42L|::(long+int)), |0=42L|::(long+int))

/** takeUntilStep

  return elements from `src` starts from `begin` until `f` returns true, and the rest elements

  template <typename T>
  std::pair<array<T>, array<T>> takeUntilStep(std::function<bool(T)> f, array<T>& src, long begin) {
    for (i = begin; begin < src.size(); ++begin) {
      if (f(src[begin])) {
        break;
      }
    }
    return {{src.cbegin() + i, src.cbegin()+begin}, {src.cbegin() + begin+1, src.cbegin()}};
  }
*/

assert(takeUntilStep(\x.x==3, [1, 2, 3, 4, 3, 2, 1], 0L), ([1, 2], [4, 3, 2, 1]))
assert(takeUntilStep(\x.x==3, [1..5], 0L), ([1, 2], [4, 5]))
assert(takeUntilStep(\x.x==7, [1..5], 0L), ([1..5], []::[int]))
assert(takeUntilStep(\x.x==1, [1..5], 0L), ([]::[int], [2..5]))

/** takeUntil

  like `takeUntilStep` but always starts from index 0
*/

assert(takeUntil(\x.x==3, [1, 2, 3, 4, 3, 2, 1]), ([1, 2], [4, 3, 2, 1]))
assert(takeUntil(\x.x==3, [1..5]), ([1, 2], [4, 5]))
assert(takeUntil(\x.x==7, [1..5]), ([1..5], []::[int]))
assert(takeUntil(\x.x==1, [1..5]), ([]::[int], [2..5]))

/** takeUntilRStep

  like `takeUntilStep` but starts from right
*/

assert(takeUntilRStep(\x.x==3, [1, 2, 3, 4, 3, 2, 1], 6L), ([1, 2, 3, 4], [2, 1]))
assert(takeUntilRStep(\x.x==3, [1..5], 4L), ([1, 2], [4, 5]))
assert(takeUntilRStep(\x.x==7, [1..5], 4L), ([]::[int], [1..5]))
assert(takeUntilRStep(\x.x==1, [1..5], 4L), ([]::[int], [2..5]))

/** takeUntileR

  like `takeUntilRStep` but always starts from the end
*/

assert(takeUntilR(\x.x==3, [1, 2, 3, 4, 3, 2, 1]), ([1, 2, 3, 4], [2, 1]))
assert(takeUntilR(\x.x==3, [1..5]), ([1, 2], [4, 5]))
assert(takeUntilR(\x.x==7, [1..5]), ([]::[int], [1..5]))
assert(takeUntilR(\x.x==1, [1..5]), ([]::[int], [2..5]))

/** just

  `maybe` type has value `x`

  template <typename T>
  maybe<T> just(T x) {
    return {x};
  }
*/

assert(just(3), |1=3|::maybeInt)

/** nothing

  `maybe` type `nothing`

  template <typename T> constexpr maybe<T> nothing = {};
*/

assert([nothing, just(3)], [|0=()|, just(3)])

/** either

  either returns the `default`, or apply `f` to the value if `maybe` type `v` has value

  template <typename T, typename U>
  U either(maybe<T> v, U default, std::function<U(T)> f) {
    if (v.isJust()) {
      return f(v.value());
    }
    return default;
  }
*/

assert(either(just(3), 42, \x.x*2), 6)
assert(either(nothing::maybeInt, 42, \x.x*2), 42)

/** eitherC

  like `either`, but `f` must be a closure
*/

assert(eitherC(just(3), 42, toClosure(\x.x*2)), 6)
assert(eitherC(nothing::maybeInt, 42, toClosure(\x.x*2)), 42)

/** isJust

  return true if `maybe` type `v` has value

  template <typename T>
  bool isJust(maybe<T> v) {
    return v.isJust();
  }
*/

assert(isJust(just(3)), true)
assert(isJust(nothing::maybeInt), false)

/** isNothing

  return true if `maybe` type `v` has no value

  template <typename T>
  bool isNothing(maybe<T> v) {
    return !v.isJust();
  }
*/

assert(isNothing(just(3)), false)
assert(isNothing(nothing::maybeInt), true)

/** isNull

  like `isNothing`
*/

assert(isNull(just(3)), false)
assert(isNull(nothing::maybeInt), true)

/** fromMaybe

  return the value of `maybe` type `v`, or `default` if `v` has no value

  template <typename T>
  T fromMaybe(T default, maybe<T> v) {
    return v.isJust() ? v.value() : default;
  }
*/

assert(fromMaybe(42, just(3)), 3)
assert(fromMaybe(42, nothing::maybeInt), 42)

/** mmap

  map a function over a `maybe` type `v`, return `nothing` if `v` has no value

  template <typename T, typename U>
  maybe<U> mmap(std::function<maybe<U>(T)> f, maybe<T> v) {
    if (v.isJust()) {
      return f(v.value());
    }
    return {};
  }
*/

assert(mmap(\x.just(x*2), just(3)), just(6))
assert(mmap(\x.just(x*2), nothing::maybeInt), nothing::maybeInt)

/** mmapC

  like `mmap`, but `f` must be a closure
*/

assert(mmapC(toClosure(\x.just(x*2)), just(3)), just(6))
assert(mmapC(toClosure(\x.just(x*2)), nothing::maybeInt), nothing::maybeInt)

/** mapm

  like `mmap`
*/

assert(mapm(\x.just(x*2), just(3)), just(6))
assert(mapm(\x.just(x*2), nothing::maybeInt), nothing::maybeInt)

/** +

  add
*/

assert(just(3) + just(4), just(7))
assert(just(3) + 4, just(7))
assert(3 + just(4), just(7))
assert(just(3) + (nothing::maybeInt), just(3))
assert(3 + (nothing::maybeInt), nothing::maybeInt)
assert((nothing::maybeInt) + just(4), just(4))
assert((nothing::maybeInt) + 4, nothing::maybeInt)
assert((nothing::maybeInt) + (nothing::maybeInt), nothing::maybeInt)

// type doesn't satisfy HasZero
assert(isJust(just('c') + just('c')), true)
assert(isJust(just('c') + 'c'), true)
assert(isJust('c' + just('c')), true)
assert(isJust(just('c') + (nothing::maybeChar)), false)
assert(isJust('c' + (nothing::maybeChar)), false)
assert(isJust((nothing::maybeChar) + just('c')), false)
assert(isJust((nothing::maybeChar) + 'c'), false)

/** -

  substract
*/
assert(just(3) - just(4), just(-1))
assert(just(3) - 4, just(-1))
assert(3 - just(4), just(-1))
assert(just(3) - (nothing::maybeInt), just(3))
assert(3 - (nothing::maybeInt), nothing::maybeInt)
assert((nothing::maybeInt) - just(4), just(-4))
assert((nothing::maybeInt) - 4, nothing::maybeInt)
assert((nothing::maybeInt) - (nothing::maybeInt), nothing::maybeInt)

// type doesn't satisfy HasZero
assert(isJust(just('c') - just('c')), true)
assert(isJust(just('c') - 'c'), true)
assert(isJust('c' - just('c')), true)
assert(isJust(just('c') - (nothing::maybeChar)), false)
assert(isJust('c' - (nothing::maybeChar)), false)
assert(isJust((nothing::maybeChar) - just('c')), false)
assert(isJust((nothing::maybeChar) - 'c'), false)

/** *

  multiply
*/
assert(just(3) * just(4), just(12))
assert(just(3) * 4, just(12))
assert(3 * just(4), just(12))
assert(just(3) * (nothing::maybeInt), just(3))
assert(3 * (nothing::maybeInt), nothing::maybeInt)
assert((nothing::maybeInt) * just(4), just(4))
assert((nothing::maybeInt) * 4, nothing::maybeInt)
assert((nothing::maybeInt) * (nothing::maybeInt), nothing::maybeInt)

/** *

  divide
*/
assert(just(12) / just(4), just(3))
assert(just(12) / 4, just(3))
assert(12 / just(4), just(3))
assert(just(12) / (nothing::maybeInt), just(12))
assert(12 / (nothing::maybeInt), nothing::maybeInt)
assert((nothing::maybeInt) / just(4), just(0)) // 1/4
assert((nothing::maybeInt) / 4, nothing::maybeInt)
assert((nothing::maybeInt) / (nothing::maybeInt), nothing::maybeInt)

/** Enum

  TODO: what is this?
*/

/** eqLenEqArrs

  compare two arrays within range [`begin`, `a.size()`)

  template <template <typename> Array, typename T>
  bool eqLenEqArrs(Array<T>& a, Array<T>& b, long begin) {
    for (; begin < a.size(); ++begin) {
      if (a[begin] != b[begin]) {
        return false;
      }
    }
    return true; 
  }
*/

assert(eqLenEqArrs([1, 2, 3], [4, 2, 3, 4], 1L), true)
assert(eqLenEqArrs([1, 2, 3], [4, 2, 4], 1L), false)
assert(eqLenEqArrs([1, 2, 3], [4, 2, 3], 0L), false)

/** eqLenEquivArrs

  compare two arrays within range [`begin`, `a.size()`)

  template <template <typename> Array, typename T, typename U>
  bool eqLenEquivArrs(Array<T>& a, Array<U>& b, long begin) {
    for (; begin < a.size(); ++begin) {
      if (static_cast<U>(a[begin]) != b[begin]) {
        return false;
      }
    }
    return true; 
  }
*/

assert(eqLenEquivArrs([1L, 2L, 3L], [4, 2, 3, 4], 1L), true)
assert(eqLenEquivArrs([1L, 2L, 3L], [4, 2, 4], 1L), false)
assert(eqLenEquivArrs([1L, 2L, 3L], [4, 2, 3], 0L), false)

/** Eq and Equiv

  ===: for same type
  == : for different types
*/

assert(() === (), true)
// TODO: Eq 0?
assert(true === true, true)
assert(false === false, true)
assert(true === false, false)
assert(false === true, false)
assert('c' === 'c', true)
assert('c' === 'x', false)
assert(0X33 === 0X33, true)
assert(0X33 === 0X11, false)
assert(3S === 3S, true)
assert(3S === 4S, false)
assert(3 === 3, true)
assert(3 === 4, false)
assert(3L === 3L, true)
assert(3L === 4L, false)
assert(3.0 === 3.0, true)
assert(3.0 === 4.0, false)
assert(3.0f === 3.0f, true)
assert(3.0f === 4.0f, false)
assert(3H === 3H, true)
assert(3H === 4H, false)
assert(3s === 3s, true)
assert(3s === 4s, false)
do {
  d = now();
  assert(d === d, true);
  assert(d === d + 1s, false);
  t = time(now());
  assert(t === t, true);
  assert(t === t + 1s, false);
}
assert((3, 3L, 3.7) === (3, 3L, 3.7), true)
assert((3, 3L, 3.7) === (3, 3L, 1.7), false)
assert({a=3, b=3L, c=3.7} === {a=3, b=3L, c=3.7}, true)
assert({a=3, b=3L, c=3.7} === {a=3, b=3L, c=1.7}, false)
assert(|A=true|::|A:bool, B:int, C:[char]| === |A=true|::|A:bool, B:int, C:[char]|, true)
assert(|A=true|::|A:bool, B:int, C:[char]| === |A=false|::|A:bool, B:int, C:[char]|, false)
assert(|A=true|::|A:bool, B:int, C:[char]| === |B=42|::|A:bool, B:int, C:[char]|, false)
assert([1, 2, 3] === [1, 2, 3], true)
assert([1, 2, 3] === [1, 2, 4], false)
assert([1, 2, 3] === [1, 2], false)
assert([1, 2, 3] === []::[int], false)
assert(cons(3, cons(4, cons(5, nil()))) === cons(3, cons(4, cons(5, nil()))), true)
assert(cons(3, cons(4, cons(5, nil()))) === cons(3, cons(4, cons(42, nil()))), false)
assert(cons(3, cons(4, cons(5, nil()))) === cons(3, cons(4, nil())), false)
assert(cons(3, cons(4, nil())) === cons(3, cons(4, cons(5, nil()))), false)

assert(just(3) === just(3), true)
assert(just(3) === just(4), false)
assert(just(3) === nothing::maybeInt, false)
assert(nothing::maybeInt === just(3), false)
assert(nothing::maybeInt === nothing::maybeInt, true)

// TODO: Eq a@f

// whatever Eq must be Equiv, but not vice versa
// if (sub)types are kind of convertible, then they are Equiv
assert(() == (), true)
// TODO: Eq 0?
assert(true == true, true)
assert(false == false, true)
assert(true == false, false)
assert(false == true, false)
assert('c' == 'c', true)
assert('c' == 'x', false)
assert(0X33 == 0X33, true)
assert(0X33 == 0X11, false)
assert(3S == 3, true)
assert(3S == 4, false)
assert(3 == 3L, true)
assert(3 == 4L, false)
assert(3H == 3L, true)
assert(3H == 4L, false)
assert(3.0f == 3.0, true)
assert(3.0 == 4.0f, false)
assert(3.0 == 3.0f, true)
assert(3.0f == 4.0, false)
assert(3H == 3, true)
assert(3H == 4, false)
assert(3000ms == 3s, true)
assert(3000ms == 4s, false)
do {
  d = now();
  assert(d == d, true);
  assert(d == d + 1s, false);
  t = time(now());
  assert(t == t, true);
  assert(t == t + 1s, false);
}
assert((3L, 3L, 3.7) == (3, 3L, 3.7), true)
assert((3L, 3L, 3.7) == (3, 3L, 1.7), false)
assert({a=3, b=3L, c=3.7} == {a=3, b=3L, c=3.7}, true)
assert({a=3, b=3L, c=3.7} == {a=3, b=3L, c=1.7}, false)
assert(|A=true|::|A:bool, B:int, C:[char]| == |A=true|::|A:bool, B:int, C:[char]|, true)
assert(|A=true|::|A:bool, B:int, C:[char]| == |A=false|::|A:bool, B:int, C:[char]|, false)
assert(|A=true|::|A:bool, B:int, C:[char]| == |B=42|::|A:bool, B:int, C:[char]|, false)
assert([1L, 2L, 3L] == [1, 2, 3], true)
assert([1L, 2L, 3L] == [1, 2, 4], false)
assert([1L, 2L, 3L] == [1, 2], false)
assert([1L, 2L, 3L] == []::[int], false)
assert(cons(3, cons(4, cons(5, nil()))) == cons(3, cons(4, cons(5, nil()))), true)
assert(cons(3, cons(4, cons(5, nil()))) == cons(3, cons(4, cons(42, nil()))), false)
assert(cons(3, cons(4, cons(5, nil()))) == cons(3, cons(4, nil())), false)
assert(cons(3, cons(4, nil())) == cons(3, cons(4, cons(5, nil()))), false)

// TODO: Equiv a@f b@g

assert(|1=3|::(char+int) == 3, true)
assert(|1=3|::(int+int) == 3, true)
assert(|0=3|::(int+int) == 3, true)
assert(|1=3|::(char+int) == 4, false)
assert(|0='c'|::(char+int) == 3, false)
assert(3 == |1=3|::(char+int), true)
assert(3 == |1=3|::(int+int), true)
assert(3 == |0=3|::(int+int), true)
assert(4 == |1=3|::(char+int), false)
assert(3 == |0='c'|::(char+int), false)

assert(just(3L) == just(3), true)
assert(just(3L) == just(4), false)
assert(just(3) == nothing::maybeInt, false)
assert(nothing::maybeInt == just(3), false)
assert(nothing::maybeInt == nothing::maybeInt, true)

/** flip

  converts from an array of records into a record of arrays
*/

assert(flip([{a=1, b=2L, c=3.7}]), {a=[1], b=[2L], c=[3.7]})
assert(flip([{a=1, b=2L}, {a=3, b=4L}]), {a=[1, 3], b=[2L, 4L]})

/** flipInto

  converts from an array of records into a record of arrays
*/

do {
  a = newPrim()::{a:[int], b:[bool]};
  flipInto([{a=1, b=true}, {a=3, b=false}], a);
  assert(a, {a=[1, 3], b=[true, false]});
}

///////////////////////////
//    C++ bindings
///////////////////////////

// negate a boolean
assert(not(true), false)
assert(not(false), true)

// bitwise negation of a byte
assert(bnot(0Xff), 0X00)
assert(bnot(0X00), 0Xff)
assert(bnot(0X33), 0Xcc)

// convert a byte to int, zero-extended
assert(b2i(0X00), 0)
assert(b2i(0Xf0), 240)

// convert a byte to long, zero-extended
assert(b2l(0X00), 0L)
assert(b2l(0Xf0), 240L)

// convert int to double
assert(i2d(3), 3.0)
assert(i2d(-3), -3.0)

// convert int to float
assert(i2f(3), 3.0f)
assert(i2f(-3), -3.0f)

// convert int to long, sign-extended
assert(i2l(3), 3L)
assert(i2l(-3), -3L)

// convert long to int128, sign-extended
assert(l2i16(3L), 3H)
assert(l2i16(-3L), -3H)

// convert long to double
assert(l2d(3L), 3.0)
assert(l2d(-3L), -3.0)

// convert long to float
assert(l2f(3L), 3.0f)
assert(l2f(-3L), -3.0f)

// convert short to int, sign-extended
assert(s2i(3S), 3)
assert(s2i(-3S), -3)

// convert float to double
assert(f2d(3.0f), 3.0)
assert(f2d(-3.0f), -3.0)

int_max = 2147483647 // 2^31 - 1
int_half_max = 1073741823 // 2^30 - 1 
int_min = neg(int_max) - 1 // -2^31, get around parser limitation

// truncate long to int by truncating the high order bits
assert(tl2i(0L), 0)
assert(tl2i(-0L), 0)
assert(tl2i(3L), 3)
assert(tl2i(-3L), -3)
assert(tl2i(i2l(int_max)), int_max)
assert(tl2i(i2l(int_max)+1L), int_min)
assert(tl2i(i2l(int_max)+2L), int_min+1)
assert(tl2i(i2l(int_min)), int_min)
assert(tl2i(i2l(int_min)-1L), int_max)
assert(tl2i(i2l(int_min)-2L), int_max-1)

short_max = 32767S // 2^15 - 1
short_min = neg(short_max) - 1S // -2^15, get around parser limitation

// truncate int to short by truncating the high order bits
assert(ti2s(0), 0S)
assert(ti2s(-0), 0S)
assert(ti2s(3), 3S)
assert(ti2s(-3), -3S)
assert(ti2s(s2i(short_max)), short_max)
assert(ti2s(s2i(short_max)+1), short_min)
assert(ti2s(s2i(short_max)+2), short_min+1)
assert(ti2s(s2i(short_min)), short_min)
assert(ti2s(s2i(short_min)-1), short_max)
assert(ti2s(s2i(short_min)-2), short_max-1)

// truncate int to byte by truncating the high order bits
assert(ti2b(0), 0X00)
assert(ti2b(-0), 0X00)
assert(ti2b(3), 0X03)
assert(ti2b(-3), 0Xfd)
assert(ti2b(b2i(0Xff)), 0Xff)
assert(ti2b(b2i(0Xff)+1), 0X00)
assert(ti2b(b2i(0Xff)+2), 0X01)

// truncate long to byte by truncating the high order bits
assert(tl2b(0L), 0X00)
assert(tl2b(-0L), 0X00)
assert(tl2b(3L), 0X03)
assert(tl2b(-3L), 0Xfd)
assert(tl2b(b2l(0Xff)), 0Xff)
assert(tl2b(b2l(0Xff)+1), 0X00)
assert(tl2b(b2l(0Xff)+2), 0X01)

// negate numbers
assert(sneg(0S), 0S)
assert(sneg(3S), -3S)
assert(sneg(-3S), 3S)

assert(ineg(0), 0)
assert(ineg(3), -3)
assert(ineg(-3), 3)

assert(lneg(0L), 0L)
assert(lneg(3L), -3L)
assert(lneg(-3L), 3L)

assert(i16neg(0H), 0H)
assert(i16neg(3H), -3H)
assert(i16neg(-3H), 3H)

assert(fneg(0.0f), 0.0f)
assert(fneg(-0.0f), 0.0f)
assert(fneg(3.0f), -3.0f)
assert(fneg(-3.0f), 3.0f)

assert(dneg(0.0), 0.0)
assert(dneg(-0.0), 0.0)
assert(dneg(3.0), -3.0)
assert(dneg(-3.0), 3.0)

// comparision
assert(ceq('c', 'c'), true)
assert(ceq('x', 'c'), false)
assert(cneq('c', 'c'), false)
assert(cneq('x', 'c'), true)
assert(clt('c', 'c'), false)
assert(clt('x', 'c'), false)
assert(clt('c', 'x'), true)
assert(clte('c', 'c'), true)
assert(clte('x', 'c'), false)
assert(clte('c', 'x'), true)
assert(cgt('c', 'c'), false)
assert(cgt('x', 'c'), true)
assert(cgt('c', 'x'), false)
assert(cgte('c', 'c'), true)
assert(cgte('x', 'c'), true)
assert(cgte('c', 'x'), false)

assert(beq(0X00, 0X00), true)
assert(beq(0X00, 0Xff), false)
assert(bneq(0X00, 0X00), false)
assert(bneq(0X00, 0Xff), true)
assert(blt(0X33, 0X33), false)
assert(blt(0X88, 0X33), false)
assert(blt(0X33, 0X88), true)
assert(blte(0X33, 0X33), true)
assert(blte(0X88, 0X33), false)
assert(blte(0X33, 0X88), true)
assert(bgt(0X33, 0X33), false)
assert(bgt(0X88, 0X33), true)
assert(bgt(0X33, 0X88), false)
assert(bgte(0X33, 0X33), true)
assert(bgte(0X88, 0X33), true)
assert(bgte(0X33, 0X88), false)

assert(seq(0S, 0S), true)
assert(seq(0S, 1S), false)
assert(sneq(0S, 0S), false)
assert(sneq(0S, 1S), true)
assert(slt(33S, 33S), false)
assert(slt(88S, 33S), false)
assert(slt(33S, 88S), true)
assert(slt(33S, -88S), false)
assert(slte(33S, 33S), true)
assert(slte(88S, 33S), false)
assert(slte(33S, 88S), true)
assert(slte(33S, -88S), false)
assert(sgt(33S, 33S), false)
assert(sgt(88S, 33S), true)
assert(sgt(33S, 88S), false)
assert(sgt(33S, -88S), true)
assert(sgte(33S, 33S), true)
assert(sgte(88S, 33S), true)
assert(sgte(33S, 88S), false)
assert(sgte(33S, -88S), true)

assert(ieq(0, 0), true)
assert(ieq(0, 1), false)
assert(ineq(0, 0), false)
assert(ineq(0, 1), true)
assert(ilt(33, 33), false)
assert(ilt(88, 33), false)
assert(ilt(33, 88), true)
assert(ilt(33, -88), false)
assert(ilte(33, 33), true)
assert(ilte(88, 33), false)
assert(ilte(33, 88), true)
assert(ilte(33, -88), false)
assert(igt(33, 33), false)
assert(igt(88, 33), true)
assert(igt(33, 88), false)
assert(igt(33, -88), true)
assert(igte(33, 33), true)
assert(igte(88, 33), true)
assert(igte(33, 88), false)
assert(igte(33, -88), true)

assert(leq(0L, 0L), true)
assert(leq(0L, 1L), false)
assert(lneq(0L, 0L), false)
assert(lneq(0L, 1L), true)
assert(llt(33L, 33L), false)
assert(llt(88L, 33L), false)
assert(llt(33L, 88L), true)
assert(llt(33L, -88L), false)
assert(llte(33L, 33L), true)
assert(llte(88L, 33L), false)
assert(llte(33L, 88L), true)
assert(llte(33L, -88L), false)
assert(lgt(33L, 33L), false)
assert(lgt(88L, 33L), true)
assert(lgt(33L, 88L), false)
assert(lgt(33L, -88L), true)
assert(lgte(33L, 33L), true)
assert(lgte(88L, 33L), true)
assert(lgte(33L, 88L), false)
assert(lgte(33L, -88L), true)

assert(i16eq(0H, 0H), true)
assert(i16eq(0H, 1H), false)
assert(i16neq(0H, 0H), false)
assert(i16neq(0H, 1H), true)
assert(i16lt(33H, 33H), false)
assert(i16lt(88H, 33H), false)
assert(i16lt(33H, 88H), true)
assert(i16lt(33H, -88H), false)
assert(i16lte(33H, 33H), true)
assert(i16lte(88H, 33H), false)
assert(i16lte(33H, 88H), true)
assert(i16lte(33H, -88H), false)
assert(i16gt(33H, 33H), false)
assert(i16gt(88H, 33H), true)
assert(i16gt(33H, 88H), false)
assert(i16gt(33H, -88H), true)
assert(i16gte(33H, 33H), true)
assert(i16gte(88H, 33H), true)
assert(i16gte(33H, 88H), false)
assert(i16gte(33H, -88H), true)

assert(feq(0.0f, 0.0f), true)
assert(feq(0.0f, 1.0f), false)
assert(fneq(0.0f, 0.0f), false)
assert(fneq(0.0f, 1.0f), true)
assert(flt(33.0f, 33.0f), false)
assert(flt(88.0f, 33.0f), false)
assert(flt(33.0f, 88.0f), true)
assert(flt(33.0f, -88.0f), false)
assert(flte(33.0f, 33.0f), true)
assert(flte(88.0f, 33.0f), false)
assert(flte(33.0f, 88.0f), true)
assert(flte(33.0f, -88.0f), false)
assert(fgt(33.0f, 33.0f), false)
assert(fgt(88.0f, 33.0f), true)
assert(fgt(33.0f, 88.0f), false)
assert(fgt(33.0f, -88.0f), true)
assert(fgte(33.0f, 33.0f), true)
assert(fgte(88.0f, 33.0f), true)
assert(fgte(33.0f, 88.0f), false)
assert(fgte(33.0f, -88.0f), true)

assert(deq(0.0, 0.0), true)
assert(deq(0.0, 1.0), false)
assert(dneq(0.0, 0.0), false)
assert(dneq(0.0, 1.0), true)
assert(dlt(33.0, 33.0), false)
assert(dlt(88.0, 33.0), false)
assert(dlt(33.0, 88.0), true)
assert(dlt(33.0, -88.0), false)
assert(dlte(33.0, 33.0), true)
assert(dlte(88.0, 33.0), false)
assert(dlte(33.0, 88.0), true)
assert(dlte(33.0, -88.0), false)
assert(dgt(33.0, 33.0), false)
assert(dgt(88.0, 33.0), true)
assert(dgt(33.0, 88.0), false)
assert(dgt(33.0, -88.0), true)
assert(dgte(33.0, 33.0), true)
assert(dgte(88.0, 33.0), true)
assert(dgte(33.0, 88.0), false)
assert(dgte(33.0, -88.0), true)

// shifting
assert(bshl(0X00, 0X01), 0X00)
assert(bshl(0X01, 0X01), 0X02)
assert(bshl(0X80, 0X01), 0X00)

assert(blshr(0X00, 0X01), 0X00)
assert(blshr(0X7f, 0X01), 0X3f)
assert(blshr(0X8f, 0X01), 0X47)

assert(bashr(0X00, 0X01), 0X00)
assert(bashr(0X7f, 0X01), 0X3f)
assert(bashr(0X8f, 0X01), 0Xc7)

assert(ishl(0, 1), 0)
assert(ishl(1, 1), 2)
assert(ishl(int_min, 1), 0)

assert(ilshr(0, 1), 0)
assert(ilshr(int_max, 1), int_half_max)
assert(ilshr(int_min, 1), int_half_max + 1)

assert(iashr(0, 1), 0)
assert(iashr(int_max, 1), int_half_max)
assert(iashr(int_min, 1), int_min + int_half_max + 1)

assert(iand(0, 0), 0)
assert(iand(0, int_max), 0)
assert(iand(int_max, 0), 0)
assert(iand(int_max, int_max), int_max)

assert(ior(0, 0), 0)
assert(ior(0, int_max), int_max)
assert(ior(int_max, 0), int_max)
assert(ior(int_max, int_max), int_max)

assert(ixor(0, 0), 0)
assert(ixor(0, int_max), int_max)
assert(ixor(int_max, 0), int_max)
assert(ixor(int_max, int_max), 0)

long_max = 9223372036854775807L // 2^63 - 1
long_half_max = 4611686018427387903L // 2^62 - 1
long_min = neg(long_max) - 1L

assert(lshl(0L, 1L), 0L)
assert(lshl(1L, 1L), 2L)
assert(lshl(long_min, 1L), 0L)

assert(llshr(0L, 1L), 0L)
assert(llshr(long_max, 1L), long_half_max)
assert(llshr(long_min, 1L), long_half_max + 1L)

assert(lashr(0L, 1L), 0L)
assert(lashr(long_max, 1L), long_half_max)
assert(lashr(long_min, 1L), long_min + long_half_max + 1L)

assert(land(0L, 0L), 0L)
assert(land(0L, long_max), 0L)
assert(land(long_max, 0L), 0L)
assert(land(long_max, long_max), long_max)

assert(lor(0L, 0L), 0L)
assert(lor(0L, long_max), long_max)
assert(lor(long_max, 0L), long_max)
assert(lor(long_max, long_max), long_max)

assert(lxor(0L, 0L), 0L)
assert(lxor(0L, long_max), long_max)
assert(lxor(long_max, 0L), long_max)
assert(lxor(long_max, long_max), 0L)

// logic comparisons
assert(band(0X00, 0X00), 0X00)
assert(band(0X00, 0Xff), 0X00)
assert(band(0Xff, 0X00), 0X00)
assert(band(0Xff, 0Xff), 0Xff)

assert(bor(0X00, 0X00), 0X00)
assert(bor(0X00, 0Xff), 0Xff)
assert(bor(0Xff, 0X00), 0Xff)
assert(bor(0Xff, 0Xff), 0Xff)

assert(bxor(0X00, 0X00), 0X00)
assert(bxor(0X00, 0Xff), 0Xff)
assert(bxor(0Xff, 0X00), 0Xff)
assert(bxor(0Xff, 0Xff), 0X00)

// arithmetic operations
assert(cadd('+', '+'), 'V')
assert(csub('V', '+'), '+')
assert(cmul('+', '+'), '9')
// don't have sensible test cases of div and rem for chars

assert(badd(0X17, 0X21), 0X38)
assert(badd(0Xff, 0X01), 0X00)

assert(bsub(0X17, 0X21), 0Xf6)
assert(bsub(0X00, 0X01), 0Xff)

assert(bmul(0X03, 0X02), 0X06)
assert(bmul(0Xff, 0X02), 0Xfe)

assert(bdiv(0X06, 0X02), 0X03)
// div returns signed quotient towards zero
assert(bdiv(0Xff, 0X02), 0X00)

assert(brem(0X06, 0X02), 0X00)
// div returns 0X00, so rem returns 0Xff
assert(brem(0Xff, 0X02), 0Xff)

assert(sadd(3S, 4S), 7S)
assert(sadd(3S, -4S), -1S)

assert(ssub(3S, 4S), -1S)
assert(ssub(3S, -4S), 7S)

assert(smul(3S, 4S), 12S)
assert(smul(3S, -4S), -12S)

assert(sdiv(12S, 4S), 3S)
assert(sdiv(13S, 4S), 3S)
// div returns signed quotient towards zero
assert(sdiv(13S, -4S), -3S)

assert(srem(12S, 4S), 0S)
assert(srem(13S, 4S), 1S)
assert(srem(13S, -4S), 1S)

assert(iadd(3, 4), 7)
assert(iadd(3, -4), -1)

assert(isub(3, 4), -1)
assert(isub(3, -4), 7)

assert(imul(3, 4), 12)
assert(imul(3, -4), -12)

assert(idiv(12, 4), 3)
assert(idiv(13, 4), 3)
// div ieturns signed quotient towards zero
assert(idiv(13, -4), -3)

assert(irem(12, 4), 0)
assert(irem(13, 4), 1)
assert(irem(13, -4), 1)

assert(ladd(3L, 4L), 7L)
assert(ladd(3L, -4L), -1L)

assert(lsub(3L, 4L), -1L)
assert(lsub(3L, -4L), 7L)

assert(lmul(3L, 4L), 12L)
assert(lmul(3L, -4L), -12L)

assert(ldiv(12L, 4L), 3L)
assert(ldiv(13L, 4L), 3L)
// div returns signed quotient towards zero
assert(ldiv(13L, -4L), -3L)

assert(lrem(12L, 4L), 0L)
assert(lrem(13L, 4L), 1L)
assert(lrem(13L, -4L), 1L)

assert(i16add(3H, 4H), 7H)
assert(i16add(3H, -4H), -1H)

assert(i16sub(3H, 4H), -1H)
assert(i16sub(3H, -4H), 7H)

assert(i16mul(3H, 4H), 12H)
assert(i16mul(3H, -4H), -12H)

assert(i16div(12H, 4H), 3H)
assert(i16div(13H, 4H), 3H)
// div i16eturns signed quotient towards zero
assert(i16div(13H, -4H), -3H)

assert(i16rem(12H, 4H), 0H)
assert(i16rem(13H, 4H), 1H)
assert(i16rem(13H, -4H), 1H)

assert(fadd(3.0f, 4.0f), 7.0f)
assert(fadd(3.0f, -4.0f), -1.0f)

assert(fsub(3.0f, 4.0f), -1.0f)
assert(fsub(3.0f, -4.0f), 7.0f)

assert(fmul(3.0f, 4.0f), 12.0f)
assert(fmul(3.0f, -4.0f), -12.0f)

assert(fdiv(12.0f, 4.0f), 3.0f)
assert(fdiv(13.0f, 4.0f), 3.25f)
assert(fdiv(13.0f, -4.0f), -3.25f)
assert(fdiv(-13.0f, -4.0f), 3.25f)

assert(dadd(3.0, 4.0), 7.0)
assert(dadd(3.0, -4.0), -1.0)

assert(dsub(3.0, 4.0), -1.0)
assert(dsub(3.0, -4.0), 7.0)

assert(dmul(3.0, 4.0), 12.0)
assert(dmul(3.0, -4.0), -12.0)

assert(ddiv(12.0, 4.0), 3.0)
assert(ddiv(13.0, 4.0), 3.25)
assert(ddiv(13.0, -4.0), -3.25)
assert(ddiv(-13.0, -4.0), 3.25)


// operands
assert(if true then () else (), ())
assert(if false then 1 else -1, -1)

assert(id(3), 3)
assert(id(()), ())

assert(unsafeCast('c')::byte, 0X63)

assert(newPrimZ()::int, 0)
// length([a])
assert(length(newArray(42L)::[double]), 42L)

// append([a], [a])
assert(append("hello", "world"), "helloworld")
assert(append([1, 2, 3], []), [1, 2, 3])

do {
  a = newArray(42L)::[int];
  unsafeSetLength(a, 3L);
  assert(length(a), 3L);
  unsafeSetLength(a, 42L);
  assert(length(a), 42L);
}

// salength([:a|n:]) length of a fix sized array
assert(salength(newPrimZ()::[:double|42:]), 42)
// saelem([:a|n:], index) mutable element at index
do {
  a = newPrimZ()::[:int|42:];
  saelem(a, 2L) <- 77;
  assert((saelem(a, 0L), saelem(a, 2L)), (0, 77));
}
// saacopy([:a|n:], [a], length) copy a dyn-sized array to a fixed size array
do {
  a = newPrimZ()::[:char|42:]; 
  saacopy(a, "hello", 5L);
  assert(a, "hello");
}

// TODO: how can applyCFn be called directly?
assert(apply(aCFn, 'c'), 'd')

assert(penumShow(|B|::((penum char |A('a'), B('b'), C('c')|))), "|B|")

assert(stdstrsize(aStdString), length("hello world"))
assert(stdstrelem(aStdString, 0L), 'h')

assert(packLong('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'), 7017280452245743464L) // 0x6162636465666768
assert(packInt('a', 'b', 'c', 'd'), 1633837924) // 0x61626364
assert(packShort('a', 'b'), 24930S) // 0x6162

assert(cptrrefby(aCStr, 0L), 'h')

// TODO: test region related functions:
//      malloc
//      mallocz
//      printMemoryPool
//      getMemoryPool
//      unsafeSetRegion
//      unsafeMakeMemRegion
//      unsafeClearMemoryPool
//      unsafeAbortAtMemUsage

assert(showChar('c'), "'c'")
assert(showByte(0Xab), "0Xab")
assert(showByteV(0Xab), "ab")
assert(showShort(13S), "13S")
assert(showShort(-13S), "-13S")
assert(showInt(13), "13")
assert(showInt(-13), "-13")
assert(showLong(13L), "13")
assert(showLong(-13L), "-13")
assert(showInt128(13H), "13")
assert(showInt128(-13H), "-13")
assert(showFloat(3.0f, 0), "3f")
assert(showFloat(3.0f, 2), "3f")
assert(showFloat(3.1f, 2), "3.1f")
assert(showFloat(3.12f, 2), "3.1f")
assert(showFloat(0.12f, 2), "0.12f")
assert(showFloat(-0.10f, 2), "-0.1f")
assert(showDouble(3.0, 0), "3")
// inconsistent with showFloat due to std::ios::fixed flag
assert(showDouble(3.0, 2), "3.00")
assert(showDouble(3.1, 2), "3.10")
assert(showDouble(3.12, 2), "3.12")
assert(showDouble(0.12, 2), "0.12")
assert(showDouble(-0.10, 2), "-0.10")

assert(showString(aStdString), "\"hello world\"")

// format date and time
assert(showTimespan(convert(0L)::timespan), "0s")
assert(showTimespan(convert(3L)::timespan), "3us")
assert(length(showDateTime(now())), 26L)
do {
  x = now();
  assert(showDateTime(x)[11:], showTime(time(x)));
  assert(append(showDateTime(x)[0:10], "T00:00:00.000000"), showDateTime(date(x)));
}
do {
  x = now();
  assert(strfdatetime("%s", now()), strftime("%s", convert(x)::long));
}
// replace the time portion of a datetime
do {
  x = now();
  assert(showDateTime(x-1s), showDateTime(datetimeAt(x, time(x-1s))));
}
// TODO: gmtoffset: GMT+/- ? timezone
// TODO: gmtime and localtime
do {
  captureStdout();
  putStr("hello");
  assert(releaseStdout(), "hello");
}

assert(readChar("'c'"), 'c')
assert(readChar("c"), nothing::maybeChar)

assert(readByte("0Xab"), 0Xab)
assert(readByte("0XAB"), 0Xab)
assert(readByte("ab"), nothing::(()+byte))
assert(readByte("0xab"), nothing::(()+byte))
assert(readByte("0Xa"), nothing::(()+byte))

assert(readShort("32767"), short_max)
assert(readShort("32767S"), short_max)
assert(readShort("32768S"), nothing::(()+short)) // overflow
assert(readShort("-32768"), short_min)
assert(readShort("-32768S"), short_min)
assert(readShort("-32769S"), nothing::(()+short)) // overflow

assert(readInt("2147483647"), int_max)
assert(readInt("2147483648"), nothing::maybeInt) // overflow
assert(readInt("-2147483648"), int_min)
assert(readInt("-2147483649"), nothing::maybeInt) // overflow

assert(readLong("9223372036854775807"), long_max)
assert(readLong("9223372036854775807L"), long_max)
assert(readLong("9223372036854775808L"), nothing::maybeLong) // overflow
assert(readLong("-9223372036854775808"), long_min)
assert(readLong("-9223372036854775808L"), long_min)
assert(readLong("-9223372036854775809L"), nothing::maybeLong) // overflow

assert(readInt128("42"), 42H)
assert(readInt128("-42"), -42H)
assert(readInt128("42H"), 42H)
assert(readInt128("-42H"), -42H)
assert(readInt128("ABC"), nothing::(()+int128))

assert(readFloat("3.0"), 3.0f)
assert(readFloat("3.0f"), 3.0f)
assert(readFloat("-3.0"), -3.0f)
assert(readFloat("-3.0f"), -3.0f)

assert(readDouble("3.0"), 3.0)
assert(readDouble("-3.0"), -3.0)

do {
  a = newArray(42L)::[char];
  stdstringAssign(aStdString, a);
  assert(aStdString, a);
}

do {
  x = random(1.0, 3.0);
  assert((x <= 3.0 and x >= 1.0), true);
}
do {
  x = lrand(1L, 3L);
  assert((x <= 3L and x >= 1L), true);
}

assert(ceil(3.1), 4.0)
assert(floor(3.1), 3.0)
assert(truncd(3.1), 3L)
assert(showDouble(sqrt(3.0) * sqrt(3.0), 2), "3.00")
do {
  x = log(3.0);
  result = 1.09861;
  delta = 0.0001;
  assert((x <= result + delta and x >= result - delta), true);
}

assert(cstrlen(aCStr), 5L)
assert(cstrelem(aCStr, 0L), 'h')

assert(decompress(compress(0xabcd)), 0xabcd)

// TODO: unit tests for runEvery?

assert(vectorSize(unsafeCast(aVec), 4L), 10)
// TODO: vectorData

// TODO: add block date reading/writing tests for:
//    fdWriteChars
//    fdWriteBytes

do {
  f = newArray(100L)::[char];
  wfd = openTempForWrite(f);
  assert(fileExists(f), true);
  fdWriteBool(wfd, true);
  fdWriteByte(wfd, 0Xab);
  fdWriteChar(wfd, 'c');
  fdWriteShort(wfd, 12S);
  fdWriteInt(wfd, 42);
  fdWriteLong(wfd, 34L);
  fdWriteInt128(wfd, 53H);
  fdWriteFloat(wfd, 7.2f);
  fdWriteDouble(wfd, 3.1);
  fdWriteLong(wfd, 5L);
  fdWriteChars(wfd, "hello");
  fdWriteLong(wfd, 4L);
  fdWriteBytes(wfd, 0xdeadbeef);
  closefd(wfd);

  rfd = openForRead(f);
  assert(fdReadBool(rfd), true);
  assert(fdReadByte(rfd), 0Xab);
  assert(fdReadChar(rfd), 'c');
  assert(fdReadShort(rfd), 12S);
  assert(fdReadInt(rfd), 42);
  assert(fdReadLong(rfd), 34L);
  assert(fdReadInt128(rfd), 53H);
  assert(fdReadFloat(rfd), 7.2f);
  assert(fdReadDouble(rfd), 3.1);
  closefd(rfd);

  removeFile(f);
  assert(fileExists(f), false);
}

// TODO: ipc related:
//    unsafeAppendClientReadFn
//    unsafeClientRead
//    printConnection
//    remoteHost

// TODO: signal related:
//    signals
//    addFileSignal
//    fileWatchData
//    LoadFile
//    load
//    pload
//    file
//    unload
//    store
//    pstore
//    allocate
//    allocateArray
//    pallocateArray
//    capacity
//    pcapacity
//    writeFile
//    signalUpdate
//    readFile
//    printFile
//    pageEntries

//    unsafeWriteToSeries
//    unsafeWriteUnitToSeries

// TODO: compressed storage related:
//    ddmMake
//    ddmInit
//    ddmDestroy
//                     
//    ucReaderMake
//    ucReaderStep
//    ucReaderSkipPage
//    ucReaderEOF
//    ucReaderFileRef
//    ucReaderModel
//    ucReaderRead
//    ucReaderDestroy
//                     
//    ucWriterMake
//    ucWriterStep
//    ucWriterModel
//    ucWriterModelData
//    ucWriterWrite
//    ucWriterDestroy

