assert = \a b.if a == b then () else println("assertion failed: " ++ show(a) ++ " != " ++ show(b))

///////////////////////////
//    native functions
///////////////////////////

/** alli

  if all elements in the array satisfy the predicate `f` from `begin`, return true
  else return false

  tempalte <typename T>
  bool alli(std::function<bool(T)> f, std::size_t begin, array<T>& xs) {
    return std::all_of(xs.cbegin() + begin, xs.cend(), f);
  }
*/

assert(alli(\x.x>3, 1L, [4]), true)
assert(alli(\x.x>3, 1L, [4, 5]), true)
assert(alli(\x.x>3, 1L, [4, 3]), false)
assert(alli(\x.x>3, 1L, [4, 3, 4]), false)
assert(alli(\x.x>3, 1L, [4, 5, 4]), true)

/** all
  
  if all elements in the array satisfy the predicate `f`, return true
  else return false

  template <typename T>
  bool all(std::function<bool(T)> f, array<T>& xs) {
    return std::all_of(xs.cbegin(), xs.cend(), f);
  }
*/

assert(all(\x.x>3, []::[int]), true)
assert(all(\x.x>3, [5]), true)
assert(all(\x.x>3, [3]), false)
assert(all(\x.x>3, [3, 4]), false)
assert(all(\x.x>3, [5, 4]), true)

/** anyi

  if any element in the array satisfies the predicate `f` from `begin`, return true
  else return false

  template <typename T>
  bool anyi(std::function<bool(T)> f, std::size_t begin, array<T>& xs) {
    return std::any_of(xs.cbegin() + begin, xs.cend(), f);
  }
*/

assert(anyi(\x.x>3, 1L, [4]), false)
assert(anyi(\x.x>3, 1L, [4, 5]), true)
assert(anyi(\x.x>3, 1L, [4, 3]), false)
assert(anyi(\x.x>3, 1L, [4, 3, 4]), true)
assert(anyi(\x.x>3, 1L, [4, 5, 4]), true)

/** any
  
  if any element in the array satisfies the predicate `f`, return true
  else return false

  template <typename T>
  bool any(std::function<bool(T)> f, array<T>& xs) {
    return std::any_of(xs.cbegin(), xs.cend(), f);
  }
*/

assert(any(\x.x>3, []::[int]), false)
assert(any(\x.x>3, [5]), true)
assert(any(\x.x>3, [3]), false)
assert(any(\x.x>3, [3, 4]), true)


/** anyiC

  just like `anyi`, but the predicate must be a closure
*/

assert(anyiC(toClosure(\x.x>3), 1L, [4]), false)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 5]), true)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 3]), false)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 3, 4]), true)
assert(anyiC(toClosure(\x.x>3), 1L, [4, 5, 4]), true)

/** anyC
  
  just like `any`, but the predicate must be a closure
*/

assert(anyC(toClosure(\x.x>3), []::[int]), false)
assert(anyC(toClosure(\x.x>3), [5]), true)
assert(anyC(toClosure(\x.x>3), [3]), false)
assert(anyC(toClosure(\x.x>3), [3, 4]), true)


/** somei

  if some elements in the array satisfy the predicate `f` from `begin`, return `maybe(T)`
  else return false

  template <typename T>
  maybe<T> somei(std::function<bool(T)> f, array<T>& xs, std::size_t begin) {
    const auto it = std::find_if(xs.cbegin() + begin, xs.cend(), f);
    return (it == xs.cend()) ? nothing<T>() : just<T>(*it);
  }
*/

assert(somei(\x.x>3, [4], 0L), 4)
assert(somei(\x.x>3, [4, 3, 5], 1L), 5)
assert(somei(\x.x>3, [4, 3, 2, 1], 1L), nothing::(()+int))

/** some

  if some elements in the array satisfy the predicate `f`, return `maybe(T)`
  else return false

  template <typename T>
  maybe<T> some(std::function<bool(T)> f, array<T>& xs) {
    const auto it = std::find_if(xs.cbegin(), xs.cend(), f);
    return (it == xs.cend()) ? nothing<T>() : just<T>(*it);
  }
*/

assert(some(\x.x>3, []::[int]), nothing::(()+int))
assert(some(\x.x>3, [3, 5]), 5)
assert(some(\x.x>3, [3, 2, 1]), nothing::(()+int))

/** someiC

  just like `somei`, but the predicate must be a closure
*/

assert(someiC(toClosure(\x.x>3), [4], 0L), 4)
assert(someiC(toClosure(\x.x>3), [4, 3, 5], 1L), 5)
assert(someiC(toClosure(\x.x>3), [4, 3, 2, 1], 1L), nothing::(()+int))

/** someC

  just like `some`, but the predicate must be a closure
*/

assert(someC(toClosure(\x.x>3), []::[int]), nothing::(()+int))
assert(someC(toClosure(\x.x>3), [3, 5]), 5)
assert(someC(toClosure(\x.x>3), [3, 2, 1]), nothing::(()+int))


/** amap

  starting from position `begin`, for every element in array `src`, apply `f` to it,
  and store the result in the corresponding position in array `dst`

  template <typename T, typename U>
  array<U>& amap(std::function<U(T)> f, std::size_t begin, array<T>& dst, array<U>& src) {
    std::transform(src.cbegin() + begin, src.cend(), dst.begin() + begin, f);
    return dst;
  }
*/

assert(amap(\x.x+1, 0L, []::[int], []::[int]), []::[int])
do {
  b = newArray(1L);
  copy(b, 0L, [3]);
  assert(amap(\x.x+1, 1L, b, [4]), b);
}
do {
  b = newArray(2L);
  copy(b, 0L, [3, 4]);
  assert(amap(\x.x+1, 0L, b, [4, 5]), [5, 6]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(amap(\x.x+1, 1L, b, [4, 5, 6]), [3, 6, 7]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(amap(\x.x+1, 1L, b, [4, 5]), [3, 6, 5]);
}

/** amapRange

  starting from position `begin` to `end` (exclusive), for every element in array `src`, apply `f` to it,
  and store the result in the corresponding position in array `dst` starts from index `dstBegin`

  template <typename T, typename U>
  array<U> amapRange(std::function<U(T)> f, array<T>& src, std::size_t begin, std::size_t end, array<T>& dst, std::size_t dstBegin) {
    std::transform(src.cbegin() + begin, src.cbegin() + end, dst.begin() + dstBegin, f);
    return dst;
  }
*/

assert(amapRange(\x.x+1, []::[int], 0L, 0L, []::[int], 0L), []::[int])
do {
  b = newArray(1L);
  copy(b, 0L, [33]);
  assert(amapRange(\x.x+1, [4], 0L, 1L, b, 0L), [5]);
}
do {
  b = newArray(2L);
  copy(b, 0L, [33, 33]);
  assert(amapRange(\x.x+1, [4, 5], 0L, 2L, b, 0L), [5, 6]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [33, 33, 33]);
  assert(amapRange(\x.x+1, [4, 5, 6], 0L, 2L, b, 1L), [33, 5, 6]);
}

/** map

  just like `amap`, but the destination array is created by the function

  template <typename T, typename U>
  array<U> map(std::function<U(T)> f, array<T>& src) {
    array<U> dst(src.size());
    std::transform(src.cbegin(), src.cend(), dst.begin(), f);
    return dst;
  }
*/

assert(map(\x.x+1, []::[int]), []::[int])
assert(map(\x.x+1, [4]), [5])
assert(map(\x.x+1, [4, 5]), [5, 6])

/** mapRange

  just like `amapRange`, but the destination array is created by the function

  template <typename T, typename U>
  array<U> mapRange(std::function<U(T)> f, std::size_t begin, std::size_t end, array<T>& src) {
    array<U> dst(end - begin);
    std::transform(src.cbegin() + begin, src.cbegin() + end, dst.begin(), f);
    return dst;
  }
*/

assert(mapRange(\x.x+1, 0L, 0L, []::[int]), []::[int])
assert(mapRange(\x.x+1, 0L, 1L, [4]), [5])
assert(mapRange(\x.x+1, 0L, 1L, [4, 5]), [5])

/** mapiC

  just like `amap`, but the function must be a closure
*/

assert(mapiC(toClosure(\x.x+1), 0L, []::[int], []::[int]), []::[int])
do {
  b = newArray(1L);
  copy(b, 0L, [3]);
  assert(mapiC(toClosure(\x.x+1), 1L, b, [4]), b);
}
do {
  b = newArray(2L);
  copy(b, 0L, [3, 4]);
  assert(mapiC(toClosure(\x.x+1), 0L, b, [4, 5]), [5, 6]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(mapiC(toClosure(\x.x+1), 1L, b, [4, 5, 6]), [3, 6, 7]);
}
do {
  b = newArray(3L);
  copy(b, 0L, [3, 4, 5]);
  assert(mapiC(toClosure(\x.x+1), 1L, b, [4, 5]), [3, 6, 5]);
}

/** mapC

  just like `map`, but the function must be a closure
*/

assert(mapC(toClosure(\x.x+1), []::[int]), []::[int])
assert(mapC(toClosure(\x.x+1), [4]), [5])
assert(mapC(toClosure(\x.x+1), [4, 5]), [5, 6])

/** mapIdxStep

  dst[i] = f(src, i);

  template <typename T, typename U>
  array<U> mapIdxStep(std::function<U(array<T>&, std::size_t)> f, array<T>& src, std::size_t begin, array<U>& dst) {
    std::transform(src.cbegin() + begin, src.cend(), dst.begin() + begin, f);
    return dst;
  }
*/

assert(mapIdxStep(\xs i.xs[i]-1, []::[int], 0L, []::[int]), []::[int])
do {
  b = newArray(3L);
  copy(b, 0L, [5, 7, 9]);
  assert(mapIdxStep(\xs i.xs[i]-1, [3, 4], 1L, b), [5, 3, 9]);
}

/** mapIdx

  just like `mapIdxStep`, but the destination array is created by the function

  template <typename T, typename U>
  array<U> mapIdx(std::function<U(array<T>&, std::size_t)> f, array<T>& src) {
    array<U> dst(src.size());
    std::transform(src.cbegin(), src.cend(), dst.begin(), f);
    return dst;
  }
*/

assert(mapIdx(\xs i.xs[i]-1, []::[int]), []::[int])
assert(mapIdx(\xs i.xs[i]-1, [3, 4]), [2, 3])

/** eachStep

  apply `f` to each element of `src` between indices [`begin`, `end`]

  template <typename T>
  void eachStep(std::function<void(T)> f, array<T>& src, std::size_t begin, std::size_t end) {
    std::for_each(src.cbegin() + begin, src.cbegin() + end + 1, f);
  }
*/

//eachStep(\x.print(x), [3, 4, 5], 1L, 2L) // prints 45

/** each

  just like `eachStep`, but apply `f` on every element of `src`

  template <typename T>
  void each(std::function<void(T)> f, array<T>& src) {
    eachStep(f, src, 0, src.size() - 1);
  }
*/

//each(\x.print(x), [3, 4, 5]) // prints 345

/** eachRange

  apply `f` to each number between [`begin`, `end`)

  template <typename T>
  void eachRange(std::function<void(T)> f, T begin, T end) {
    for (T i = begin; i < end; ++i) {
      f(i);
    }
  }
*/

// eachRagne(\x.print(x), 1, 3) // prints 12

/** eachiC

  just like `each`, but `f` must be a closure, and has a `begin` index

  template <typename T>
  void eachiC(std::function<void(T)> f, array<T>& src, T begin) {
    for (T i = begin; T <= src.size() - 1; ++i) {
      f(i);
    }
  }
*/

// eachiC(toClosure(print), [3, 4, 5], 1L) // prints 45

/** eachC

  just like `each`, but `f` must be a closure

  template <typename T>
  void eachC(std::function<void(T)> f, array<T>& src) {
    for (T i = 0; i <= src.size() - 1; ++i) {
      f(i);
    }
  }
*/

// eachC(toClosure(print), [3, 4, 5]) // prints 345

/** eachRangeC

  just like `eachRange`, but `f` must be a closure

  template <typename T>
  void eachRangeC(std::function<void(T)> f, T begin, T end) {
    for (T i = begin; i < end; ++i) {
      f(i);
    }
  }
*/

// eachRangeC(toClosure(print), 1, 3) // prints 12

/** foldli

  fold left from index `begin`

  template <typename T, typename Acc>
  U foldli(std::function<Acc(Acc, T)> f, Acc init, std::size_t begin, array<T>& src) {
    return std::accumulate(src.cbegin() + begin, src.cend(), init, f);
  }
*/

assert(foldli(\acc x.acc+x, 0, 0L, []::[int]), 0)
assert(foldli(\acc x.acc+x, 42, 1L, [3]), 42)
assert(foldli(\acc x.acc+x, 42, 1L, [1, 2, 3]), 42 + 2 + 3)

/** foldliRange

  fold left from index `begin` to `end` (exclusive)

  template <typename T, typename Acc>
  U foldliRange(std::function<Acc(Acc, T)> f, Acc init, std::size_t begin, std::size_t end, array<T>& src) {
    return std::accumulate(src.cbegin() + begin, src.cbegin() + end, init, f);
  }
*/

assert(foldliRange(\acc x.acc+x, 0, 0L, 0L, []::[int]), 0)
assert(foldliRange(\acc x.acc+x, 42, 0L, 1L, [3]), 42 + 3)
assert(foldliRange(\acc x.acc+x, 42, 1L, 3L, [3, 4, 5, 6]), 42 + 4 + 5)

/** foldlRange

  same as `foldliRange`, could be a mistake in `foldliRange`'s signature for missing starting index
*/

assert(foldlRange(\acc x.acc+x, 0, 0L, 0L, []::[int]), 0)
assert(foldlRange(\acc x.acc+x, 42, 0L, 1L, [3]), 42 + 3)
assert(foldlRange(\acc x.acc+x, 42, 1L, 3L, [3, 4, 5, 6]), 42 + 4 + 5)

/** copyRange

  copy elements from `src` between indices [`begin`, `end`) to `dst` starts from `dstStartIdx`

  template <typename T>
  void copyRange(array<T>& dst, std::size_t dstStartIdx, array<T>& src, std::size_t begin, std::size_t end) {
    std::copy(src.cbegin() + begin, src.cbegin() + end, dst.begin() + dstStartIdx);
  }
*/

do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyRange(b, 0L, [3, 4, 5], 1L, 2L);
  assert(b, [4, 33, 33]);
}
do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyRange(b, 1L, [3, 4, 5], 1L, 2L);
  assert(b, [33, 4, 33]);
}

/** copyFrom

  copy elements from `src` between `begin` to its end to `dst` starts from `dstStartIdx`

  template <typename T>
  void copyFrom(array<T>& dst, std::size_t dstStartIdx, array<T>& src, std::size_t begin) {
    std::copy(src.cbegin() + begin, src.cend(), dst.begin() + dstStartIdx);
  }
*/

do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyFrom(b, 0L, [3, 4, 5], 1L);
  assert(b, [4, 5, 33]);
}
do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copyFrom(b, 1L, [3, 4, 5], 1L);
  assert(b, [33, 4, 5]);
}

/** copy

  copy elements from `src` to `dst` starts from `dstStartIdx`

  template <typename T>
  void copy(array<T>& dst, std::size_t dstStartIdx, array<T>& src) {
    std::copy(src.cbegin(), src.cend(), dst.begin() + dstStartIdx);
  }
*/

do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  assert(b, [33, 33, 33]);
}
do {
  b = newArray(3L)::[int];
  copy(b, 0L, [33, 33, 33]);
  copy(b, 1L, [3, 4, 5]);
  assert(b, [33, 3, 4]);
}

/** concatInto

  concat elements from `src` starts with index `begin`, and copy them into `dst` starts from `dstStartIdx`

  template <typename T>
  void concatInto(array<array<T>>& src, std::size_t begin, array<T>& dst, std::size_t dstBegin) {
    for (std::size_t i = begin; i < src.size(); ++i) {
      std::copy(src[i].cbegin(), src[i].cend(), dst.begin() + dstBegin);
      dstBegin += src[i].size();
    }
  }
*/

assert(concatInto(["hello", "abc", "defg"], 1L, newArray(7L), 0L), "abcdefg")

/** concat

  create an array contains the result of concated elements from `src`

  template <typename T>
  array<T> concat(array<array<T>>& src, array<T>& dst) {
    const auto size = std::accumulate(src.cbegin(), src.cend(), 0, [](std::size_t acc, const array<T>& x) {
      return acc + x.size();
    });
    array<T> result(size);
    std::size_t dstBegin = 0;
    for (std::size_t i = 0, dstBegin = 0; i < src.size(); ++i) {
      std::copy(src[i].cbegin(), src[i].cend(), result.begin() + dstBegin);
      dstBegin += src[i].size();
    }
    return result;
  }
*/

assert(concat(["hello", "abc", "defg"]), "helloabcdefg")

/** convert

  convert array of type T to array of type U, if T -> U is convertible
*/

assert(convert([3S, 4S])::[int], [3, 4])

/** foldl

  fold left

  template <typename T, typename Acc>
  U foldl(std::function<Acc(Acc, T)> f, Acc init, array<T>& src) {
    return std::accumulate(src.begin(), src.end(), init, f);
  }
*/

assert(foldl(\acc x.acc+x, 0, []::[int]), 0)
assert(foldl(\acc x.acc+x, 42, [3]), 42 + 3)
assert(foldl(\acc x.acc+x, 42, [1, 2, 3]), 42 + 1 + 2 + 3)

/** foldri

  fold right from index `begin`-1

  template <typename T, typename Acc>
  U foldri(std::function<Acc(Acc, T)> f, Acc init, std::size_t begin, array<T>& src) {
    return std::accumulate(src.rbegin() + begin, src.rend(), init, f);
  }
*/

assert(foldri(\acc x.acc+x, 42, 1L, [3]), 42 + 3)
assert(foldri(\acc x.acc+x, 42, 1L, [1, 2, 3]), 42 + 1)

/** foldr

  fold right

  template <typename T, typename Acc>
  U foldr(std::function<Acc(Acc, T)> f, Acc init, array<T>& src) {
    return std::accumulate(src.rbegin(), src.rend(), init, f);
  }
*/

assert(foldr(\acc x.acc+x, 42, []::[int]), 42)
assert(foldr(\acc x.acc+x, 42, [3]), 42 + 3)
assert(foldr(\acc x.acc+x, 42, [1, 2, 3]), 42 + 1 + 2 + 3)

/** scanlStep

  scan left from index `begin`

  template <typename T, typename Acc>
  array<Acc> scanlStep(std::function<Acc(Acc, T)> f, Acc init, std::size_t begin, array<T>& src) {
    array<Acc> result(src.size() - begin + 1);
    std::exclusive_scan(src.cbegin() + begin, src.cend(), result.begin(), f);
    return result;
  }
*/

do {
  b = newArray(5L);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(scanlStep(\acc x.acc+x, 0, [1, 2, 3], 0L, b), [0, 1, 3, 6, 33]);
}

do {
  b = newArray(5L);
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(scanlStep(\acc x.acc+x, 42, [1, 2, 3], 1L, b), [33, 42, 44, 47, 33]);
}

/** scanl

  scan left

  template <typename T, typename Acc>
  array<Acc> scanl(std::function<Acc(Acc, T)> f, Acc init, array<T>& src) {
    array<Acc> result(src.size() + 1);
    std::exclusive_scan(src.cbegin(), src.cend(), result.begin(), init, f);
    return result;
  }
*/

assert(scanl(\acc x.acc+x, 42, [1, 2, 3]), [42, 43, 45, 48])

/** foldlT2Step

  fold left from index `begin` over pairs

  template <typename T1, typename T2, typename Acc>
  U foldlT2Step(std::function<Acc(Acc, std::tuple<T1, T2>> f, Acc init, array<std::tuple<T1, T2>>& src, std::size_t begin) {
    return std::accumulate(src1.cbegin() + begin, src1.cend(), init, f);
  }
*/

assert(foldlT2Step(\acc a b.acc+a+b, 42, [(1, 2), (3, 4), (5, 6)], 1L), 42 + (3+4) + (5+6))

/** foldlT2

  fold left over pairs

  template <typename T1, typename T2, typename Acc>
  U foldlT2(std::function<Acc(Acc, std::tuple<T1, T2>> f, Acc init, array<std::tuple<T1, T2>>& src) {
    return std::accumulate(src.cbegin(), src.cend(), init, f);
  }
*/

assert(foldlT2(\acc a b.acc+a+b, 42, [(1, 2), (3, 4), (5, 6)]), 42 + (1+2) + (3+4) + (5+6))

/** foldlCT2Step

  just like `foldlT2Step`, but the predicate must be a closure
*/

assert(foldlCT2Step(toClosure(\x.x.0+(x.1*x.2)), 42, [(1, 2), (3, 4), (5, 6)], 1L), 42 + (3*4) + (5*6))

/** foldlCT2

  just like `foldlT2`, but the predicate must be a closure
*/

assert(foldlCT2(toClosure(\x.x.0+(x.1*x.2)), 42, [(1, 2), (3, 4), (5, 6)]), 42 + (1*2) + (3*4) + (5*6))

/** findIter

  find the first element in the array that satisfies the predicate, starts from `begin`, return `maybe<T>`

  template <typename T>
  maybe<T> findIter(std::function<bool(T)> f, array<T>& src, std::size_t begin) {
    const auto it = std::find_if(src.cbegin() + begin, src.cend(), f);
    return it == src.cend() ? nothing() : just(*it);
  }
*/

assert(findIter(\x.x > 3, [1, 2, 3, 4, 5], 0L), just(4))
assert(findIter(\x.x == 3, [1, 2, 3, 4, 5], 3L), nothing::(()+int))

/** find

  find the first element in the array that satisfies the predicate, return `maybe<T>`

  template <typename T>
  maybe<T> find(std::function<bool(T)> f, array<T>& src) {
    const auto it = std::find_if(src.cbegin(), src.cend(), f);
    return it == src.cend() ? nothing() : just(*it);
  }
*/

assert(find(\x.x > 3, [1, 2, 3, 4, 5]), just(4))
assert(find(\x.x == 7, [1, 2, 3, 4, 5]), nothing::(()+int))

/** countTrues

  count how many values in the array satisfy the predicate `f`, starts from `begin`

  template <typename T>
  std::size_t countTrues(std::function<bool(T)> f, std::size_t init, array<bool>& src, std::size_t begin) {
    return init + std::count_if(src.cbegin() + begin, src.cend(), f);
  }
*/

assert(countTrues(\x.x == 3, 42L, [3, 5, 3, 7, 3], 0L), 42L + 3L)
assert(countTrues(\x.x == 3, 42L, [3, 5, 3, 7, 3], 1L), 42L + 2L)
assert(countTrues(\x.x == 3, 42L, [1, 2, 4], 1L), 42L)


/** countTrue

  count the number of `true` in the array

  template <typename T>
  std::size_t countTrue(std::function<bool(T)> f, array<bool>& src) {
    return init + std::count_if(src.cbegin(), src.cend(), f);
  }
*/

assert(countTrue(\x.x == 3, [3, 5, 3, 7, 3]), 3L)
assert(countTrue(\x.x == 3, [1, 2, 4]), 0L)
assert(countTrue(\x.x == 3, []::[int]), 0L)

/** counts

  counts the total result of `f` on each element with initial value `init`, starts from `begin`

  template <typename T>
  std::size_t counts(std::function<bool(T)> f, std::size_t init, array<T>& src, std::size_t begin) {
    return std::accumulate(src.cbegin() + begin, src.cend(), init, f);
  }
*/

assert(counts(length, 42L, ["abc", "defg"], 0L), 42L + 7L)
assert(counts(length, 42L, ["abc", "defg"], 1L), 42L + 4L)

/** count

  counts the total result of `f` on each element with initial value `init`

  template <typename T>
  std::size_t count(std::function<bool(T)> f, array<T>& src) {
    return std::accumulate(src.cbegin() + begin, src.cend(), init, f);
  }
*/

assert(count(length, ["abc", "defg"]), 7L)
assert(count(length, ["abc", "defg"]), 7L)

/** sum

  sum the values in the array, starts from `begin`

  template <typename T>
  T sum(array<T>& src) {
    return std::accumulate(src.cbegin(), src.cend(), T{});
  }
*/

assert(sum([1, 2, 3, 4, 5]), 1 + 2 + 3 + 4 + 5)
assert(sum([]::[int]), 0)

/** rangeInto

  copy integers from `low` to `high` (inclusive) to array `dst` starts from `begin`

  template <typename T>
  array<T> rangeInto(T low, T high, array<T>& dst, std::size_t begin) {
    std::iota(dst.begin() + begin, dst.begin() + begin + (high - low + 1), low);
  }
*/

do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(rangeInto(1, 5, b, 0L), [1, 2, 3, 4, 5]);
}
do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(rangeInto(1, 5, b, 1L), [33, 1, 2, 3, 4]);
}
do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(rangeInto(1, 0, b, 2L), [33, 33, 33, 33, 33]);
}

/** range

  create an array of integers from `begin` to `end` (inclusive)

  template <typename T>
  array<T> range(T low, T high) {
    array<T> result(high - low + 1);
    std::iota(result.begin(), result.end(), low);
    return result;
  }
*/

assert(range(1, 5), [1, 2, 3, 4, 5])
assert(range(1, 0), []::[int])

/** arepeat

  fill `dst` with `value` starts from `begin`

  template <typename T>
  array<T> arepeat(T value, std::size_t begin, array<T>& dst) {
    for (std::size_t i = 0; i < n; ++i) {
      dst[i] = value;
    }
    return dst;
  }
*/

do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(arepeat(1, 0L, b), [1, 1, 1, 1, 1]);
}
do {
  b = newArray(5L)::[int];
  copy(b, 0L, [33, 33, 33, 33, 33]);
  assert(arepeat(1, 1L, b), [33, 1, 1, 1, 1]);
}

/** repeat

  create an array of `value` with length `n`

  template <typename T>
  array<T> repeat(T value, std::size_t n) {
    array<T> result(n);
    for (std::size_t i = 0; i < n; ++i) {
      result[i] = value;
    }
    return result;
  }
*/

assert(repeat(1, 5L), [1, 1, 1, 1, 1])
assert(repeat(1, 0L), []::[int])

/** max

  compare two values and return the larger one

  template <typename T>
  T max(T a, T b) {
    return std::max(a, b);
  }

  ** IMPORTANT **

  `max` and `min` works differently in C++, see [alg.sorting.general]/5:

  > A sequence is sorted if, for every iterator `i` and non-negative integer `n`, `*(i+n) < *i` is `false`

  that is, if `x` == `y`, then `std::min(x, y) == x` and `std::max(x, y) == y`,
  however, in hobbes, `min(x, y) == y` and `max(y, y) `.  Theirs stability pereferences are different
*/

assert(max(1, 2), 2)

/** min

  compare two values and return the smaller one

  template <typename T>
  T min(T a, T b) {
    return std::min(a, b);
  }

  see ** IMPORTANT ** note in `max`
*/

assert(min(1, 2), 1)

/** maximum

  find the largest value which is larger than `value` in the array, otherwise return `value`

  template <typename T>
  T maximum(T value, array<T>& src) {
      const auto v = std::max_element(src.cbegin(), src.cend());
      return value > v ? value : v;
  }
*/

assert(maximum(1, [1, 2, 3, 4, 5]), 5)
assert(maximum(6, [1, 2, 3, 4, 5]), 6)

/** minumum

  find the smallest value which is smaller than `value` in the array, otherwise return `value`

  template <typename T>
  T minimum(T value, array<T>& src) {
      const auto v = std::min_element(src.cbegin(), src.cend());
      return value < v ? value : v;
  }
*/

assert(minimum(1, [1, 2, 0, 4, 5]), 0)
assert(minimum(6, [7, 8]), 6)

/** normIdx

  normalize an index to be in the range of [0, size]. Used for slicing, clamp the index to the range of [0, size)

  template <typename T, typename I>
  T normIdx(array<T>& src, I idx) {
    return idx < 0 ? std::max(idx + size, 0) : std::min(idx, src.size());
  }
*/

assert(normIdx([1, 2, 3, 4, 5], 0), 0)
assert(normIdx([1, 2, 3, 4, 5], 1), 1)
assert(normIdx([1, 2, 3, 4, 5], 5), 5)
assert(normIdx([1, 2, 3, 4, 5], 6), min(5L, 6L))
assert(normIdx([1, 2, 3, 4, 5], -1), max(0L, 5L-1L))
assert(normIdx([1, 2, 3, 4, 5], -6), max(0L, 5L-6L))

/** slice

  slice an array with `start` and `end` index

  if index is negative, it will be normalized to be in the range of [0, size] by `normIdx`

  after normalization, if `start` >= `end`, returns a reversed `slice(array, end, start)`
*/

do {
  b = [1, 2, 3, 4, 5];
  assert(slice(b, 0, 5), [1, 2, 3, 4, 5]);
  assert(slice(b, 1, 3), [2, 3]);
  assert(slice(b, 1, -1), slice(b, 1, 5-1));
  assert(slice(b, -2, -1), slice(b, 5-2, 5-1));
  assert(slice(b, -2, 7), slice(b, 5-2, 5));
  assert(slice(b, 7, -2), reverse(slice(b, 5-2, 5)));
}

/** cdelim

  join an array of string with a delimiter

  array<string> cdelim(array<string>& src, string delim) {
    array<string> result;
    for (std::size_t i = 0; i <= src.size() - 1; ++i) {
      result.copy(src[i].cbegin(), src[i].cend(), std::back_inserter(result));
      result.copy(delim.cbegin(), delim.cend(), std::back_inserter(result));
    }
    if (src.size() > 0) {
      result.copy(src.back().cbegin(), src.back().cend(), std::back_inserter(result));
    }
    return result;
  }
*/

assert(cdelim(["a", "b", "c"], ","), "a,b,c")
assert(cdelim(["a", "b", "c"], ""), "abc")
assert(cdelim(["abc", "bcd", "cdefg"], "<->"), "abc<->bcd<->cdefg")

/** zip

  zip two arrays into an array of pairs

  template <typename T, typename U>
  array<pair<T, U>> zip(array<T>& a, array<U>& b) {
    array<std::pair<T, U>> result;
    std::transform(a.cbegin(), a.cbegin() + std::min(a.size(), b.size()), b.cbegin(), std::back_inserter(result), [](T x, U y) {
      return std::make_pair(x, y);
    });
    return result;
  }
*/

assert(zip([1, 2, 3], [4, 5, 6]), [(1, 4), (2, 5), (3, 6)])
assert(zip([1, 2, 3], [4, 5]), [(1, 4), (2, 5)])
assert(zip([1, 2], [4, 5, 6]), [(1, 4), (2, 5)])

/** zipWith

  zip two arrays into an array of pairs, and apply a function `f` to each pair

  template <typename T, typename U, typename R>
  array<R> zipWith(std::function<R(T, U)> f, array<T>& a, array<U>& b) {
    array<R> result;
    std::transform(a.cbegin(), a.cbegin() + std::min(a.size(), b.size()), b.cbegin(), std::back_inserter(result), f);
    return result;
  }
*/

assert(zipWith(\x y.x+y, [1, 2, 3], [4, 5, 6]), [5, 7, 9])
assert(zipWith(\x y.x+y, [1, 2, 3], [4, 5]), [5, 7])
assert(zipWith(\x y.x+y, [1, 2], [4, 5, 6]), [5, 7])

/** unzipStep

  unzip an array of pairs into two arrays, all arrays start with index `begin` and end with index `end`

  template <typename T, typename U>
  void unzipStep(array<std::pair<T, U>>& src, array<T>& a, array<U>& b, std::size_t begin, std::size_t end) {
    while (begin < src.size()) {
      a[begin](s[begin].first);
      b[begin](s[begin].second);
      ++begin;
    }
  }
*/

do {
  a = [1, 2, 3];
  b = [4, 5, 6];
  c = zip(a, b);

  a1 = newArray(size(a));
  copy(a1, 0L, [33, 33, 33]);
  b1 = newArray(size(b));
  copy(b1, 0L, [44, 44, 44]);

  unzipStep(c, a1, b1, 0L, size(c));
  assert(a1, a);
  assert(b1, b);

  copy(a1, 0L, [33, 33, 33]);
  copy(b1, 0L, [44, 44, 44]);
  unzipStep(c, a1, b1, 1L, size(c)-1);
  assert(a1, [33, 2, 33]);
  assert(b1, [44, 5, 44]);
}

/** unzip

  unzip an array of pairs into two arrays

  template <typename T, typename U>
  std::pair<array<T>, array<U>> unzip(array<std::pair<T, U>>& src) {
    array<T> a;
    array<U> b;
    for (const auto& s: src) {
      a.push_back(s.first);
      b.push_back(s.second);
    }
    return std::make_pair(a, b);
  }
*/

assert(unzip([(1, 4), (2, 5), (3, 6)]), ([1, 2, 3], [4, 5, 6]))
assert(unzip([(1, 4), (2, 5)]), ([1, 2], [4, 5]))

/** ArrayIndex

  arrayIndexFrom: anything that can be converted to long
*/

assert(arrayIndexFrom(42L), 42L)
assert(arrayIndexFrom(42), 42L)
assert(arrayIndexFrom(42S), 42L)
assert(arrayIndexFrom(0X2A), 42L)

/** Function

  apply: apply a function to a value
*/

assert(apply(\x.x+1, 42), 43)
assert(apply(toClosure(\x.x+1), 42L), 43L)

/** toClosure

  convert a function to a closure
*/

assert(apply(toClosure(\x.x+1), 42), 43)

/** Array

  size: number of elements in an array
  element: element at index
  elementM: maybe element at index
  elements: range of elements
*/

assert(size([1, 2, 3]), 3L)
assert(element([1, 2, 3], 1L), 2)
assert(elementM([1, 2, 3], 1L), just(2))
assert(elementM([1, 2, 3], 100L), nothing::(()+int))
assert(elements([1, 2, 3], 1L, 3L), [2, 3])
// TODO: what's the proper behavior here?
//assert(elements([1, 2, 3], 1L, 5L), [2, 3])

/** Convert
  
  convert: convert a value to another type
*/

assert(convert(42L)::long, 42L)

///////////////////////////
//    C++ bindings
///////////////////////////

// negate a boolean
assert(not(true), false)
assert(not(false), true)

// bitwise negation of a byte
assert(bnot(0Xff), 0X00)
assert(bnot(0X00), 0Xff)
assert(bnot(0X33), 0Xcc)

// convert a byte to int, zero-extended
assert(b2i(0X00), 0)
assert(b2i(0Xf0), 240)

// convert a byte to long, zero-extended
assert(b2l(0X00), 0L)
assert(b2l(0Xf0), 240L)

// convert int to double
assert(i2d(3), 3.0)
assert(i2d(-3), -3.0)

// convert int to float
assert(i2f(3), 3.0f)
assert(i2f(-3), -3.0f)

// convert int to long, sign-extended
assert(i2l(3), 3L)
assert(i2l(-3), -3L)

// convert long to int128, sign-extended
assert(l2i16(3L), 3H)
assert(l2i16(-3L), -3H)

// convert long to double
assert(l2d(3L), 3.0)
assert(l2d(-3L), -3.0)

// convert long to float
assert(l2f(3L), 3.0f)
assert(l2f(-3L), -3.0f)

// convert short to int, sign-extended
assert(s2i(3S), 3)
assert(s2i(-3S), -3)

// convert float to double
assert(f2d(3.0f), 3.0)
assert(f2d(-3.0f), -3.0)

int_max = 2147483647 // 2^31 - 1
int_half_max = 1073741823 // 2^30 - 1 
int_min = neg(int_max) - 1 // -2^31, get around parser limitation

// truncate long to int by truncating the high order bits
assert(tl2i(0L), 0)
assert(tl2i(-0L), 0)
assert(tl2i(3L), 3)
assert(tl2i(-3L), -3)
assert(tl2i(i2l(int_max)), int_max)
assert(tl2i(i2l(int_max)+1L), int_min)
assert(tl2i(i2l(int_max)+2L), int_min+1)
assert(tl2i(i2l(int_min)), int_min)
assert(tl2i(i2l(int_min)-1L), int_max)
assert(tl2i(i2l(int_min)-2L), int_max-1)

short_max = 32767S // 2^15 - 1
short_min = neg(short_max) - 1S // -2^15, get around parser limitation

// truncate int to short by truncating the high order bits
assert(ti2s(0), 0S)
assert(ti2s(-0), 0S)
assert(ti2s(3), 3S)
assert(ti2s(-3), -3S)
assert(ti2s(s2i(short_max)), short_max)
assert(ti2s(s2i(short_max)+1), short_min)
assert(ti2s(s2i(short_max)+2), short_min+1)
assert(ti2s(s2i(short_min)), short_min)
assert(ti2s(s2i(short_min)-1), short_max)
assert(ti2s(s2i(short_min)-2), short_max-1)

// truncate int to byte by truncating the high order bits
assert(ti2b(0), 0X00)
assert(ti2b(-0), 0X00)
assert(ti2b(3), 0X03)
assert(ti2b(-3), 0Xfd)
assert(ti2b(b2i(0Xff)), 0Xff)
assert(ti2b(b2i(0Xff)+1), 0X00)
assert(ti2b(b2i(0Xff)+2), 0X01)

// truncate long to byte by truncating the high order bits
assert(tl2b(0L), 0X00)
assert(tl2b(-0L), 0X00)
assert(tl2b(3L), 0X03)
assert(tl2b(-3L), 0Xfd)
assert(tl2b(b2l(0Xff)), 0Xff)
assert(tl2b(b2l(0Xff)+1), 0X00)
assert(tl2b(b2l(0Xff)+2), 0X01)

// negate numbers
assert(sneg(0S), 0S)
assert(sneg(3S), -3S)
assert(sneg(-3S), 3S)

assert(ineg(0), 0)
assert(ineg(3), -3)
assert(ineg(-3), 3)

assert(lneg(0L), 0L)
assert(lneg(3L), -3L)
assert(lneg(-3L), 3L)

assert(i16neg(0H), 0H)
assert(i16neg(3H), -3H)
assert(i16neg(-3H), 3H)

assert(fneg(0.0f), 0.0f)
assert(fneg(-0.0f), 0.0f)
assert(fneg(3.0f), -3.0f)
assert(fneg(-3.0f), 3.0f)

assert(dneg(0.0), 0.0)
assert(dneg(-0.0), 0.0)
assert(dneg(3.0), -3.0)
assert(dneg(-3.0), 3.0)

// comparision
assert(ceq('c', 'c'), true)
assert(ceq('x', 'c'), false)
assert(cneq('c', 'c'), false)
assert(cneq('x', 'c'), true)
assert(clt('c', 'c'), false)
assert(clt('x', 'c'), false)
assert(clt('c', 'x'), true)
assert(clte('c', 'c'), true)
assert(clte('x', 'c'), false)
assert(clte('c', 'x'), true)
assert(cgt('c', 'c'), false)
assert(cgt('x', 'c'), true)
assert(cgt('c', 'x'), false)
assert(cgte('c', 'c'), true)
assert(cgte('x', 'c'), true)
assert(cgte('c', 'x'), false)

assert(beq(0X00, 0X00), true)
assert(beq(0X00, 0Xff), false)
assert(bneq(0X00, 0X00), false)
assert(bneq(0X00, 0Xff), true)
assert(blt(0X33, 0X33), false)
assert(blt(0X88, 0X33), false)
assert(blt(0X33, 0X88), true)
assert(blte(0X33, 0X33), true)
assert(blte(0X88, 0X33), false)
assert(blte(0X33, 0X88), true)
assert(bgt(0X33, 0X33), false)
assert(bgt(0X88, 0X33), true)
assert(bgt(0X33, 0X88), false)
assert(bgte(0X33, 0X33), true)
assert(bgte(0X88, 0X33), true)
assert(bgte(0X33, 0X88), false)

assert(seq(0S, 0S), true)
assert(seq(0S, 1S), false)
assert(sneq(0S, 0S), false)
assert(sneq(0S, 1S), true)
assert(slt(33S, 33S), false)
assert(slt(88S, 33S), false)
assert(slt(33S, 88S), true)
assert(slt(33S, -88S), false)
assert(slte(33S, 33S), true)
assert(slte(88S, 33S), false)
assert(slte(33S, 88S), true)
assert(slte(33S, -88S), false)
assert(sgt(33S, 33S), false)
assert(sgt(88S, 33S), true)
assert(sgt(33S, 88S), false)
assert(sgt(33S, -88S), true)
assert(sgte(33S, 33S), true)
assert(sgte(88S, 33S), true)
assert(sgte(33S, 88S), false)
assert(sgte(33S, -88S), true)

assert(ieq(0, 0), true)
assert(ieq(0, 1), false)
assert(ineq(0, 0), false)
assert(ineq(0, 1), true)
assert(ilt(33, 33), false)
assert(ilt(88, 33), false)
assert(ilt(33, 88), true)
assert(ilt(33, -88), false)
assert(ilte(33, 33), true)
assert(ilte(88, 33), false)
assert(ilte(33, 88), true)
assert(ilte(33, -88), false)
assert(igt(33, 33), false)
assert(igt(88, 33), true)
assert(igt(33, 88), false)
assert(igt(33, -88), true)
assert(igte(33, 33), true)
assert(igte(88, 33), true)
assert(igte(33, 88), false)
assert(igte(33, -88), true)

assert(leq(0L, 0L), true)
assert(leq(0L, 1L), false)
assert(lneq(0L, 0L), false)
assert(lneq(0L, 1L), true)
assert(llt(33L, 33L), false)
assert(llt(88L, 33L), false)
assert(llt(33L, 88L), true)
assert(llt(33L, -88L), false)
assert(llte(33L, 33L), true)
assert(llte(88L, 33L), false)
assert(llte(33L, 88L), true)
assert(llte(33L, -88L), false)
assert(lgt(33L, 33L), false)
assert(lgt(88L, 33L), true)
assert(lgt(33L, 88L), false)
assert(lgt(33L, -88L), true)
assert(lgte(33L, 33L), true)
assert(lgte(88L, 33L), true)
assert(lgte(33L, 88L), false)
assert(lgte(33L, -88L), true)

assert(i16eq(0H, 0H), true)
assert(i16eq(0H, 1H), false)
assert(i16neq(0H, 0H), false)
assert(i16neq(0H, 1H), true)
assert(i16lt(33H, 33H), false)
assert(i16lt(88H, 33H), false)
assert(i16lt(33H, 88H), true)
assert(i16lt(33H, -88H), false)
assert(i16lte(33H, 33H), true)
assert(i16lte(88H, 33H), false)
assert(i16lte(33H, 88H), true)
assert(i16lte(33H, -88H), false)
assert(i16gt(33H, 33H), false)
assert(i16gt(88H, 33H), true)
assert(i16gt(33H, 88H), false)
assert(i16gt(33H, -88H), true)
assert(i16gte(33H, 33H), true)
assert(i16gte(88H, 33H), true)
assert(i16gte(33H, 88H), false)
assert(i16gte(33H, -88H), true)

assert(feq(0.0f, 0.0f), true)
assert(feq(0.0f, 1.0f), false)
assert(fneq(0.0f, 0.0f), false)
assert(fneq(0.0f, 1.0f), true)
assert(flt(33.0f, 33.0f), false)
assert(flt(88.0f, 33.0f), false)
assert(flt(33.0f, 88.0f), true)
assert(flt(33.0f, -88.0f), false)
assert(flte(33.0f, 33.0f), true)
assert(flte(88.0f, 33.0f), false)
assert(flte(33.0f, 88.0f), true)
assert(flte(33.0f, -88.0f), false)
assert(fgt(33.0f, 33.0f), false)
assert(fgt(88.0f, 33.0f), true)
assert(fgt(33.0f, 88.0f), false)
assert(fgt(33.0f, -88.0f), true)
assert(fgte(33.0f, 33.0f), true)
assert(fgte(88.0f, 33.0f), true)
assert(fgte(33.0f, 88.0f), false)
assert(fgte(33.0f, -88.0f), true)

assert(deq(0.0, 0.0), true)
assert(deq(0.0, 1.0), false)
assert(dneq(0.0, 0.0), false)
assert(dneq(0.0, 1.0), true)
assert(dlt(33.0, 33.0), false)
assert(dlt(88.0, 33.0), false)
assert(dlt(33.0, 88.0), true)
assert(dlt(33.0, -88.0), false)
assert(dlte(33.0, 33.0), true)
assert(dlte(88.0, 33.0), false)
assert(dlte(33.0, 88.0), true)
assert(dlte(33.0, -88.0), false)
assert(dgt(33.0, 33.0), false)
assert(dgt(88.0, 33.0), true)
assert(dgt(33.0, 88.0), false)
assert(dgt(33.0, -88.0), true)
assert(dgte(33.0, 33.0), true)
assert(dgte(88.0, 33.0), true)
assert(dgte(33.0, 88.0), false)
assert(dgte(33.0, -88.0), true)

// shifting
assert(bshl(0X00, 0X01), 0X00)
assert(bshl(0X01, 0X01), 0X02)
assert(bshl(0X80, 0X01), 0X00)

assert(blshr(0X00, 0X01), 0X00)
assert(blshr(0X7f, 0X01), 0X3f)
assert(blshr(0X8f, 0X01), 0X47)

assert(bashr(0X00, 0X01), 0X00)
assert(bashr(0X7f, 0X01), 0X3f)
assert(bashr(0X8f, 0X01), 0Xc7)

assert(ishl(0, 1), 0)
assert(ishl(1, 1), 2)
assert(ishl(int_min, 1), 0)

assert(ilshr(0, 1), 0)
assert(ilshr(int_max, 1), int_half_max)
assert(ilshr(int_min, 1), int_half_max + 1)

assert(iashr(0, 1), 0)
assert(iashr(int_max, 1), int_half_max)
assert(iashr(int_min, 1), int_min + int_half_max + 1)

assert(iand(0, 0), 0)
assert(iand(0, int_max), 0)
assert(iand(int_max, 0), 0)
assert(iand(int_max, int_max), int_max)

assert(ior(0, 0), 0)
assert(ior(0, int_max), int_max)
assert(ior(int_max, 0), int_max)
assert(ior(int_max, int_max), int_max)

assert(ixor(0, 0), 0)
assert(ixor(0, int_max), int_max)
assert(ixor(int_max, 0), int_max)
assert(ixor(int_max, int_max), 0)

long_max = 9223372036854775807L // 2^63 - 1
long_half_max = 4611686018427387903L // 2^62 - 1
long_min = neg(long_max) - 1L

assert(lshl(0L, 1L), 0L)
assert(lshl(1L, 1L), 2L)
assert(lshl(long_min, 1L), 0L)

assert(llshr(0L, 1L), 0L)
assert(llshr(long_max, 1L), long_half_max)
assert(llshr(long_min, 1L), long_half_max + 1L)

assert(lashr(0L, 1L), 0L)
assert(lashr(long_max, 1L), long_half_max)
assert(lashr(long_min, 1L), long_min + long_half_max + 1L)

assert(land(0L, 0L), 0L)
assert(land(0L, long_max), 0L)
assert(land(long_max, 0L), 0L)
assert(land(long_max, long_max), long_max)

assert(lor(0L, 0L), 0L)
assert(lor(0L, long_max), long_max)
assert(lor(long_max, 0L), long_max)
assert(lor(long_max, long_max), long_max)

assert(lxor(0L, 0L), 0L)
assert(lxor(0L, long_max), long_max)
assert(lxor(long_max, 0L), long_max)
assert(lxor(long_max, long_max), 0L)

// logic comparisons
assert(band(0X00, 0X00), 0X00)
assert(band(0X00, 0Xff), 0X00)
assert(band(0Xff, 0X00), 0X00)
assert(band(0Xff, 0Xff), 0Xff)

assert(bor(0X00, 0X00), 0X00)
assert(bor(0X00, 0Xff), 0Xff)
assert(bor(0Xff, 0X00), 0Xff)
assert(bor(0Xff, 0Xff), 0Xff)

assert(bxor(0X00, 0X00), 0X00)
assert(bxor(0X00, 0Xff), 0Xff)
assert(bxor(0Xff, 0X00), 0Xff)
assert(bxor(0Xff, 0Xff), 0X00)

// arithmetic operations
assert(cadd('+', '+'), 'V')
assert(csub('V', '+'), '+')
assert(cmul('+', '+'), '9')
// don't have sensible test cases of div and rem for chars

assert(badd(0X17, 0X21), 0X38)
assert(badd(0Xff, 0X01), 0X00)

assert(bsub(0X17, 0X21), 0Xf6)
assert(bsub(0X00, 0X01), 0Xff)

assert(bmul(0X03, 0X02), 0X06)
assert(bmul(0Xff, 0X02), 0Xfe)

assert(bdiv(0X06, 0X02), 0X03)
// div returns signed quotient towards zero
assert(bdiv(0Xff, 0X02), 0X00)

assert(brem(0X06, 0X02), 0X00)
// div returns 0X00, so rem returns 0Xff
assert(brem(0Xff, 0X02), 0Xff)

assert(sadd(3S, 4S), 7S)
assert(sadd(3S, -4S), -1S)

assert(ssub(3S, 4S), -1S)
assert(ssub(3S, -4S), 7S)

assert(smul(3S, 4S), 12S)
assert(smul(3S, -4S), -12S)

assert(sdiv(12S, 4S), 3S)
assert(sdiv(13S, 4S), 3S)
// div returns signed quotient towards zero
assert(sdiv(13S, -4S), -3S)

assert(srem(12S, 4S), 0S)
assert(srem(13S, 4S), 1S)
assert(srem(13S, -4S), 1S)

assert(iadd(3, 4), 7)
assert(iadd(3, -4), -1)

assert(isub(3, 4), -1)
assert(isub(3, -4), 7)

assert(imul(3, 4), 12)
assert(imul(3, -4), -12)

assert(idiv(12, 4), 3)
assert(idiv(13, 4), 3)
// div ieturns signed quotient towards zero
assert(idiv(13, -4), -3)

assert(irem(12, 4), 0)
assert(irem(13, 4), 1)
assert(irem(13, -4), 1)

assert(ladd(3L, 4L), 7L)
assert(ladd(3L, -4L), -1L)

assert(lsub(3L, 4L), -1L)
assert(lsub(3L, -4L), 7L)

assert(lmul(3L, 4L), 12L)
assert(lmul(3L, -4L), -12L)

assert(ldiv(12L, 4L), 3L)
assert(ldiv(13L, 4L), 3L)
// div returns signed quotient towards zero
assert(ldiv(13L, -4L), -3L)

assert(lrem(12L, 4L), 0L)
assert(lrem(13L, 4L), 1L)
assert(lrem(13L, -4L), 1L)

assert(i16add(3H, 4H), 7H)
assert(i16add(3H, -4H), -1H)

assert(i16sub(3H, 4H), -1H)
assert(i16sub(3H, -4H), 7H)

assert(i16mul(3H, 4H), 12H)
assert(i16mul(3H, -4H), -12H)

assert(i16div(12H, 4H), 3H)
assert(i16div(13H, 4H), 3H)
// div i16eturns signed quotient towards zero
assert(i16div(13H, -4H), -3H)

assert(i16rem(12H, 4H), 0H)
assert(i16rem(13H, 4H), 1H)
assert(i16rem(13H, -4H), 1H)

assert(fadd(3.0f, 4.0f), 7.0f)
assert(fadd(3.0f, -4.0f), -1.0f)

assert(fsub(3.0f, 4.0f), -1.0f)
assert(fsub(3.0f, -4.0f), 7.0f)

assert(fmul(3.0f, 4.0f), 12.0f)
assert(fmul(3.0f, -4.0f), -12.0f)

assert(fdiv(12.0f, 4.0f), 3.0f)
assert(fdiv(13.0f, 4.0f), 3.25f)
assert(fdiv(13.0f, -4.0f), -3.25f)
assert(fdiv(-13.0f, -4.0f), 3.25f)

assert(dadd(3.0, 4.0), 7.0)
assert(dadd(3.0, -4.0), -1.0)

assert(dsub(3.0, 4.0), -1.0)
assert(dsub(3.0, -4.0), 7.0)

assert(dmul(3.0, 4.0), 12.0)
assert(dmul(3.0, -4.0), -12.0)

assert(ddiv(12.0, 4.0), 3.0)
assert(ddiv(13.0, 4.0), 3.25)
assert(ddiv(13.0, -4.0), -3.25)
assert(ddiv(-13.0, -4.0), 3.25)


// operands
assert(if true then () else (), ())
assert(if false then 1 else -1, -1)

assert(id(3), 3)
assert(id(()), ())

assert(unsafeCast('c')::byte, 0X63)

assert(newPrimZ()::int, 0)
// length([a])
assert(length(newArray(42L)::[double]), 42L)

// append([a], [a])
assert(append("hello", "world"), "helloworld")
assert(append([1, 2, 3], []), [1, 2, 3])

do {
  a = newArray(42L)::[int];
  unsafeSetLength(a, 3L);
  assert(length(a), 3L);
  unsafeSetLength(a, 42L);
  assert(length(a), 42L);
}

// salength([:a|n:]) length of a fix sized array
assert(salength(newPrimZ()::[:double|42:]), 42)
// saelem([:a|n:], index) mutable element at index
do {
  a = newPrimZ()::[:int|42:];
  saelem(a, 2L) <- 77;
  assert((saelem(a, 0L), saelem(a, 2L)), (0, 77));
}
// saacopy([:a|n:], [a], length) copy a dyn-sized array to a fixed size array
do {
  a = newPrimZ()::[:char|42:]; 
  saacopy(a, "hello", 5L);
  assert(a, "hello");
}

// TODO: how can applyCFn be called directly?
assert(apply(aCFn, 'c'), 'd')

assert(penumShow(|B|::((penum char |A('a'), B('b'), C('c')|))), "|B|")

assert(stdstrsize(aStdString), length("hello world"))
assert(stdstrelem(aStdString, 0L), 'h')

assert(packLong('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'), 7017280452245743464L) // 0x6162636465666768
assert(packInt('a', 'b', 'c', 'd'), 1633837924) // 0x61626364
assert(packShort('a', 'b'), 24930S) // 0x6162

assert(cptrrefby(aCStr, 0L), 'h')

// TODO: test region related functions:
//      malloc
//      mallocz
//      printMemoryPool
//      getMemoryPool
//      unsafeSetRegion
//      unsafeMakeMemRegion
//      unsafeClearMemoryPool
//      unsafeAbortAtMemUsage

assert(showChar('c'), "'c'")
assert(showByte(0Xab), "0Xab")
assert(showByteV(0Xab), "ab")
assert(showShort(13S), "13S")
assert(showShort(-13S), "-13S")
assert(showInt(13), "13")
assert(showInt(-13), "-13")
assert(showLong(13L), "13")
assert(showLong(-13L), "-13")
assert(showInt128(13H), "13")
assert(showInt128(-13H), "-13")
assert(showFloat(3.0f, 0), "3f")
assert(showFloat(3.0f, 2), "3f")
assert(showFloat(3.1f, 2), "3.1f")
assert(showFloat(3.12f, 2), "3.1f")
assert(showFloat(0.12f, 2), "0.12f")
assert(showFloat(-0.10f, 2), "-0.1f")
assert(showDouble(3.0, 0), "3")
// inconsistent with showFloat due to std::ios::fixed flag
assert(showDouble(3.0, 2), "3.00")
assert(showDouble(3.1, 2), "3.10")
assert(showDouble(3.12, 2), "3.12")
assert(showDouble(0.12, 2), "0.12")
assert(showDouble(-0.10, 2), "-0.10")

assert(showString(aStdString), "\"hello world\"")

// format date and time
assert(showTimespan(convert(0L)::timespan), "0s")
assert(showTimespan(convert(3L)::timespan), "3us")
assert(length(showDateTime(now())), 26L)
do {
  x = now();
  assert(showDateTime(x)[11:], showTime(time(x)));
  assert(append(showDateTime(x)[0:10], "T00:00:00.000000"), showDateTime(date(x)));
}
do {
  x = now();
  assert(strfdatetime("%s", now()), strftime("%s", convert(x)::long));
}
// replace the time portion of a datetime
do {
  x = now();
  assert(showDateTime(x-1s), showDateTime(datetimeAt(x, time(x-1s))));
}
// TODO: gmtoffset: GMT+/- ? timezone
// TODO: gmtime and localtime
do {
  captureStdout();
  putStr("hello");
  assert(releaseStdout(), "hello");
}

assert(readChar("'c'"), 'c')
assert(readChar("c"), nothing::(()+char))

assert(readByte("0Xab"), 0Xab)
assert(readByte("0XAB"), 0Xab)
assert(readByte("ab"), nothing::(()+byte))
assert(readByte("0xab"), nothing::(()+byte))
assert(readByte("0Xa"), nothing::(()+byte))

assert(readShort("32767"), short_max)
assert(readShort("32767S"), short_max)
assert(readShort("32768S"), nothing::(()+short)) // overflow
assert(readShort("-32768"), short_min)
assert(readShort("-32768S"), short_min)
assert(readShort("-32769S"), nothing::(()+short)) // overflow

assert(readInt("2147483647"), int_max)
assert(readInt("2147483648"), nothing::(()+int)) // overflow
assert(readInt("-2147483648"), int_min)
assert(readInt("-2147483649"), nothing::(()+int)) // overflow

assert(readLong("9223372036854775807"), long_max)
assert(readLong("9223372036854775807L"), long_max)
assert(readLong("9223372036854775808L"), nothing::(()+long)) // overflow
assert(readLong("-9223372036854775808"), long_min)
assert(readLong("-9223372036854775808L"), long_min)
assert(readLong("-9223372036854775809L"), nothing::(()+long)) // overflow

assert(readInt128("42"), 42H)
assert(readInt128("-42"), -42H)
assert(readInt128("42H"), 42H)
assert(readInt128("-42H"), -42H)
assert(readInt128("ABC"), nothing::(()+int128))

assert(readFloat("3.0"), 3.0f)
assert(readFloat("3.0f"), 3.0f)
assert(readFloat("-3.0"), -3.0f)
assert(readFloat("-3.0f"), -3.0f)

assert(readDouble("3.0"), 3.0)
assert(readDouble("-3.0"), -3.0)

do {
  a = newArray(42L)::[char];
  stdstringAssign(aStdString, a);
  assert(aStdString, a);
}

do {
  x = random(1.0, 3.0);
  assert((x <= 3.0 and x >= 1.0), true);
}
do {
  x = lrand(1L, 3L);
  assert((x <= 3L and x >= 1L), true);
}

assert(ceil(3.1), 4.0)
assert(floor(3.1), 3.0)
assert(truncd(3.1), 3L)
assert(showDouble(sqrt(3.0) * sqrt(3.0), 2), "3.00")
do {
  x = log(3.0);
  result = 1.09861;
  delta = 0.0001;
  assert((x <= result + delta and x >= result - delta), true);
}

assert(cstrlen(aCStr), 5L)
assert(cstrelem(aCStr, 0L), 'h')

assert(decompress(compress(0xabcd)), 0xabcd)

// TODO: unit tests for runEvery?

assert(vectorSize(unsafeCast(aVec), 4L), 10)
// TODO: vectorData

// TODO: add block date reading/writing tests for:
//    fdWriteChars
//    fdWriteBytes

do {
  f = newArray(100L)::[char];
  wfd = openTempForWrite(f);
  assert(fileExists(f), true);
  fdWriteBool(wfd, true);
  fdWriteByte(wfd, 0Xab);
  fdWriteChar(wfd, 'c');
  fdWriteShort(wfd, 12S);
  fdWriteInt(wfd, 42);
  fdWriteLong(wfd, 34L);
  fdWriteInt128(wfd, 53H);
  fdWriteFloat(wfd, 7.2f);
  fdWriteDouble(wfd, 3.1);
  fdWriteLong(wfd, 5L);
  fdWriteChars(wfd, "hello");
  fdWriteLong(wfd, 4L);
  fdWriteBytes(wfd, 0xdeadbeef);
  closefd(wfd);

  rfd = openForRead(f);
  assert(fdReadBool(rfd), true);
  assert(fdReadByte(rfd), 0Xab);
  assert(fdReadChar(rfd), 'c');
  assert(fdReadShort(rfd), 12S);
  assert(fdReadInt(rfd), 42);
  assert(fdReadLong(rfd), 34L);
  assert(fdReadInt128(rfd), 53H);
  assert(fdReadFloat(rfd), 7.2f);
  assert(fdReadDouble(rfd), 3.1);
  closefd(rfd);

  removeFile(f);
  assert(fileExists(f), false);
}

// TODO: ipc related:
//    unsafeAppendClientReadFn
//    unsafeClientRead
//    printConnection
//    remoteHost

// TODO: signal related:
//    signals
//    addFileSignal
//    fileWatchData
//    LoadFile
//    load
//    pload
//    file
//    unload
//    store
//    pstore
//    allocate
//    allocateArray
//    pallocateArray
//    capacity
//    pcapacity
//    writeFile
//    signalUpdate
//    readFile
//    printFile
//    pageEntries

//    unsafeWriteToSeries
//    unsafeWriteUnitToSeries

// TODO: compressed storage related:
//    ddmMake
//    ddmInit
//    ddmDestroy
//                     
//    ucReaderMake
//    ucReaderStep
//    ucReaderSkipPage
//    ucReaderEOF
//    ucReaderFileRef
//    ucReaderModel
//    ucReaderRead
//    ucReaderDestroy
//                     
//    ucWriterMake
//    ucWriterStep
//    ucWriterModel
//    ucWriterModelData
//    ucWriterWrite
//    ucWriterDestroy

